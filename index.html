<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background: #1a1a1a;
            color: #00ff00;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
        }
        
        h1, h2 {
            color: #00cc00;
            margin-bottom: 20px;
        }
        
        .panel {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid #555;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #00ff00;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 10px;
            background: #222;
            color: #00ff00;
            border: 1px solid #555;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        button {
            padding: 10px 20px;
            background: #006600;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-family: 'Courier New', monospace;
        }
        
        button:hover {
            background: #008800;
        }
        
        .byte-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .byte {
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            min-width: 60px;
            font-weight: bold;
        }
        
        .original {
            background: #004400;
        }
        
        .encrypted {
            background: #440044;
        }
        
        .debug {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            border: 1px solid #555;
            font-size: 14px;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
        }
        
        .success {
            background: #004400;
            color: #00ff00;
        }
        
        .error {
            background: #440000;
            color: #ff0000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</h1>
        
        <div class="panel">
            <h2>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
            <div class="input-group">
                <label for="key">–ö–ª—é—á:</label>
                <input type="text" id="key" value="secret_key_123">
            </div>
            
            <div class="input-group">
                <label for="homophonesCount">–û–º–æ—Ñ–æ–Ω–æ–≤ –Ω–∞ –±–∞–π—Ç:</label>
                <select id="homophonesCount">
                    <option value="2">2</option>
                    <option value="4" selected>4</option>
                    <option value="8">8</option>
                </select>
            </div>
            
            <button onclick="initSystem()">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É</button>
        </div>

        <div class="panel">
            <h2>üìù –î–∞–Ω–Ω—ã–µ</h2>
            <div class="input-group">
                <label for="inputData">–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:</label>
                <textarea id="inputData">Hello World! –¢–µ—Å—Ç 123</textarea>
            </div>
            
            <button onclick="encrypt()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="decrypt()">–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
        </div>

        <div class="panel">
            <h2>üîç –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è</h2>
            <div id="visualization" class="byte-visualization">
                <!-- –ë—É–¥–µ—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω–æ —Å–∫—Ä–∏–ø—Ç–æ–º -->
            </div>
        </div>

        <div class="panel">
            <h2>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç</h2>
            <div class="input-group">
                <label for="outputData">–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:</label>
                <textarea id="outputData" readonly></textarea>
            </div>
            
            <div id="status" class="status">–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ</div>
        </div>

        <div class="debug">
            <h2>üêõ –û—Ç–ª–∞–¥–∫–∞</h2>
            <div id="debugInfo">–°–∏—Å—Ç–µ–º–∞ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞</div>
        </div>
    </div>

    <script>
        class ByteHomophonicCipher {
            constructor() {
                this.table = new Map();    // original ‚Üí [homophones]
                this.reverseTable = new Map(); // homophone ‚Üí {original, index}
                this.initialized = false;
            }

            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —Å –∫–ª—é—á–æ–º
            initialize(key, homophonesCount) {
                this.table.clear();
                this.reverseTable.clear();
                
                // –°–æ–∑–¥–∞–µ–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π RNG –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                let seed = 0;
                for (let i = 0; i < key.length; i++) {
                    seed = (seed << 5) - seed + key.charCodeAt(i);
                }
                
                const rng = () => {
                    seed = (seed * 1664525 + 1013904223) % 4294967296;
                    return seed / 4294967296;
                };

                // –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–π –ø—É–ª –≤—Å–µ—Ö –±–∞–π—Ç–æ–≤ (0-255)
                const allBytes = Array.from({length: 256}, (_, i) => i);
                for (let i = allBytes.length - 1; i > 0; i--) {
                    const j = Math.floor(rng() * (i + 1));
                    [allBytes[i], allBytes[j]] = [allBytes[j], allBytes[i]];
                }

                let byteIndex = 0;

                // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞
                for (let original = 0; original < 256; original++) {
                    const homophones = [];
                    
                    for (let i = 0; i < homophonesCount; i++) {
                        if (byteIndex >= allBytes.length) {
                            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∑–∞–Ω–æ–≤–æ –µ—Å–ª–∏ –ø—É–ª –∑–∞–∫–æ–Ω—á–∏–ª—Å—è
                            for (let j = allBytes.length - 1; j > 0; j--) {
                                const k = Math.floor(rng() * (j + 1));
                                [allBytes[j], allBytes[k]] = [allBytes[k], allBytes[j]];
                            }
                            byteIndex = 0;
                        }
                        
                        const homophone = allBytes[byteIndex++];
                        homophones.push(homophone);
                        
                        // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é —Ç–∞–±–ª–∏—Ü—É
                        this.reverseTable.set(homophone, {
                            original: original,
                            index: i
                        });
                    }
                    
                    this.table.set(original, homophones);
                }
                
                this.initialized = true;
                return true;
            }

            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Å—Å–∏–≤–∞ –±–∞–π—Ç–æ–≤
            encrypt(data) {
                if (!this.initialized) throw new Error("–°–∏—Å—Ç–µ–º–∞ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞");
                
                const result = new Uint8Array(data.length * 2);
                const steps = [];
                
                for (let i = 0; i < data.length; i++) {
                    const byte = data[i];
                    
                    if (!this.table.has(byte)) {
                        // –ï—Å–ª–∏ –±–∞–π—Ç–∞ –Ω–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤—Å–µ–≥–¥–∞ –¥–ª—è 0-255)
                        result[i * 2] = 0;
                        result[i * 2 + 1] = byte;
                        steps.push({ original: byte, homophone: byte, index: 0 });
                        continue;
                    }
                    
                    const homophones = this.table.get(byte);
                    const index = Math.floor(Math.random() * homophones.length);
                    const homophone = homophones[index];
                    
                    result[i * 2] = index;
                    result[i * 2 + 1] = homophone;
                    
                    steps.push({ original: byte, homophone: homophone, index: index });
                }
                
                return { data: result, steps: steps };
            }

            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Å—Å–∏–≤–∞ –±–∞–π—Ç–æ–≤
            decrypt(encryptedData) {
                if (!this.initialized) throw new Error("–°–∏—Å—Ç–µ–º–∞ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞");
                if (encryptedData.length % 2 !== 0) throw new Error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –¥–∞–Ω–Ω—ã—Ö");
                
                const result = new Uint8Array(encryptedData.length / 2);
                
                for (let i = 0; i < encryptedData.length; i += 2) {
                    const index = encryptedData[i];
                    const homophone = encryptedData[i + 1];
                    
                    if (!this.reverseTable.has(homophone)) {
                        throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ–º–æ—Ñ–æ–Ω: ${homophone}`);
                    }
                    
                    const info = this.reverseTable.get(homophone);
                    
                    if (info.index !== index) {
                        throw new Error(`–ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∏–Ω–¥–µ–∫—Å–∞: –æ–∂–∏–¥–∞–ª–æ—Å—å ${info.index}, –ø–æ–ª—É—á–µ–Ω–æ ${index}`);
                    }
                    
                    result[i / 2] = info.original;
                }
                
                return result;
            }

            // –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–∞–±–ª–∏—Ü–µ
            getTableInfo() {
                return {
                    size: this.table.size,
                    homophonesPerByte: this.table.get(0)?.length || 0
                };
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        const cipher = new ByteHomophonicCipher();
        let lastEncryptionSteps = [];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
        function initSystem() {
            const key = document.getElementById('key').value;
            const homophonesCount = parseInt(document.getElementById('homophonesCount').value);
            
            try {
                cipher.initialize(key, homophonesCount);
                updateStatus('–°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ', 'success');
                updateDebugInfo(`–¢–∞–±–ª–∏—Ü–∞: ${cipher.getTableInfo().size} –±–∞–π—Ç–æ–≤, ${cipher.getTableInfo().homophonesPerByte} –æ–º–æ—Ñ–æ–Ω–æ–≤ –Ω–∞ –±–∞–π—Ç`);
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + error.message, 'error');
            }
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
        function encrypt() {
            const input = document.getElementById('inputData').value;
            
            if (!input) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }
            
            try {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –≤ –±–∞–π—Ç—ã
                const encoder = new TextEncoder();
                const data = encoder.encode(input);
                
                // –®–∏—Ñ—Ä—É–µ–º
                const result = cipher.encrypt(data);
                lastEncryptionSteps = result.steps;
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                const output = Array.from(result.data).join(' ');
                document.getElementById('outputData').value = output;
                
                // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º
                visualizeProcess();
                updateStatus('–î–∞–Ω–Ω—ã–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ', 'success');
                
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
        function decrypt() {
            const input = document.getElementById('inputData').value.trim();
            
            if (!input) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }
            
            try {
                // –ü–∞—Ä—Å–∏–º –±–∞–π—Ç—ã –∏–∑ —Å—Ç—Ä–æ–∫–∏
                const bytes = input.split(' ').map(Number);
                if (bytes.some(isNaN)) {
                    throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —á–∏—Å–ª–∞');
                }
                
                const encryptedData = new Uint8Array(bytes);
                
                // –î–µ—à–∏—Ñ—Ä—É–µ–º
                const decryptedData = cipher.decrypt(encryptedData);
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É
                const decoder = new TextDecoder();
                const output = decoder.decode(decryptedData);
                
                document.getElementById('outputData').value = output;
                updateStatus('–î–∞–Ω–Ω—ã–µ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ', 'success');
                
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞
        function visualizeProcess() {
            const container = document.getElementById('visualization');
            container.innerHTML = '';
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 10 —à–∞–≥–æ–≤
            const stepsToShow = lastEncryptionSteps.slice(0, 10);
            
            stepsToShow.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.style.display = 'flex';
                stepDiv.style.gap = '10px';
                stepDiv.style.marginBottom = '10px';
                stepDiv.style.alignItems = 'center';
                
                const original = document.createElement('div');
                original.className = 'byte original';
                original.textContent = step.original;
                original.title = `–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±–∞–π—Ç: ${step.original}`;
                
                const arrow = document.createElement('div');
                arrow.textContent = '‚Üí';
                arrow.style.color = '#888';
                
                const homophone = document.createElement('div');
                homophone.className = 'byte encrypted';
                homophone.textContent = step.homophone;
                homophone.title = `–û–º–æ—Ñ–æ–Ω (–∏–Ω–¥–µ–∫—Å ${step.index}): ${step.homophone}`;
                
                stepDiv.appendChild(original);
                stepDiv.appendChild(arrow);
                stepDiv.appendChild(homophone);
                
                container.appendChild(stepDiv);
            });
            
            if (lastEncryptionSteps.length > 10) {
                const more = document.createElement('div');
                more.textContent = `... –∏ –µ—â–µ ${lastEncryptionSteps.length - 10} –±–∞–π—Ç–æ–≤`;
                more.style.color = '#888';
                more.style.fontSize = '14px';
                container.appendChild(more);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        function updateStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
        function updateDebugInfo(info) {
            document.getElementById('debugInfo').textContent = info;
        }

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = function() {
            initSystem();
        };
    </script>
</body>
</html>
