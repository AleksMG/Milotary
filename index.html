<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</title>
    <style>
        :root {
            --primary: #1a365d;
            --secondary: #2a69ac;
            --accent: #e53e3e;
            --success: #38a169;
            --warning: #d69e2e;
            --light: #f7fafc;
            --dark: #2d3748;
            --border: #e2e8f0;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Fira Code', 'Courier New', monospace;
        }
        
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #0f172a 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1.6;
            color: #e2e8f0;
        }
        
        .container {
            background: rgba(26, 32, 44, 0.95);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            padding: 40px;
            width: 100%;
            max-width: 1400px;
            margin: 20px;
            border: 1px solid #2d3748;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }
        
        h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
            background: linear-gradient(45deg, #63b3ed, #4299e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        h2 {
            color: #90cdf4;
            margin: 25px 0 15px;
            font-size: 1.8rem;
        }
        
        h3 {
            color: #a0aec0;
            margin: 20px 0 12px;
            font-size: 1.4rem;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 968px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: #2d3748;
            border-radius: 12px;
            padding: 28px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #4a5568;
        }
        
        .input-group {
            margin-bottom: 24px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e2e8f0;
            font-size: 0.95em;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 14px;
            border: 2px solid #4a5568;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
            background: #1a202c;
            color: #e2e8f0;
        }
        
        input:focus, textarea:focus, select:focus {
            border-color: #4299e1;
            outline: none;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }
        
        textarea {
            min-height: 140px;
            resize: vertical;
            line-height: 1.5;
        }
        
        .btn-group {
            display: flex;
            gap: 16px;
            margin: 28px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 140px;
        }
        
        .btn-encrypt {
            background: linear-gradient(45deg, #2b6cb0, #2c5282);
            color: white;
        }
        
        .btn-decrypt {
            background: linear-gradient(45deg, #e53e3e, #c53030);
            color: white;
        }
        
        .btn-generate {
            background: linear-gradient(45deg, #38a169, #2f855a);
            color: white;
        }
        
        .process-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        .byte-block {
            background: #4a5568;
            border-radius: 6px;
            padding: 12px;
            min-width: 80px;
            text-align: center;
            position: relative;
            transition: all 0.3s;
        }
        
        .original-byte {
            background: #2b6cb0;
        }
        
        .homophone-byte {
            background: #38a169;
        }
        
        .arrow {
            font-size: 24px;
            display: flex;
            align-items: center;
            color: #90cdf4;
        }
        
        .id-bits {
            position: absolute;
            top: -20px;
            left: 0;
            right: 0;
            font-size: 12px;
            color: #f6ad55;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }
        
        .stat-card {
            background: #1a202c;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #4a5568;
        }
        
        .stat-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #63b3ed;
            margin: 8px 0;
        }
        
        .byte-table {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: #1a202c;
            border-radius: 8px;
        }
        
        .byte-item {
            background: #2d3748;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            font-size: 14px;
            text-align: center;
        }
        
        .byte-value {
            font-weight: bold;
            color: #63b3ed;
        }
        
        .warning {
            background: #742a2a;
            border: 1px solid #e53e3e;
            color: #fed7d7;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 0.9em;
        }
        
        .hex-view {
            font-family: 'Fira Code', monospace;
            background: #1a202c;
            padding: 16px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            overflow-x: auto;
            line-height: 1.8;
        }
        
        .hex-byte {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            border-radius: 3px;
            background: #2d3748;
        }
        
        .original-hex {
            background: #2b6cb0;
        }
        
        .homophone-hex {
            background: #38a169;
        }
        
        .id-hex {
            background: #f6ad55;
            color: #1a202c;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</h1>
            <p>–î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–º–æ—Ñ–æ–Ω–æ–≤ –∏–∑ –∫–ª—é—á–∞ ‚Ä¢ –ü–æ–ª–Ω–∞—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞</p>
        </div>

        <div class="warning">
            <strong>‚ö†Ô∏è –í–ê–ñ–ù–û:</strong> –≠—Ç–æ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤ —Å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º ID –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è.
        </div>

        <div class="grid">
            <div class="card">
                <h2>üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏—Å—Ç–µ–º—ã</h2>
                <div class="input-group">
                    <label for="masterKey">–ú–∞—Å—Ç–µ—Ä-–∫–ª—é—á (–ª—é–±–∞—è —Å—Ç—Ä–æ–∫–∞):</label>
                    <input type="text" id="masterKey" value="–°–µ–∫—Ä–µ—Ç–Ω—ã–π–ö–ª—é—á2024!" placeholder="–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á">
                </div>
                
                <div class="input-group">
                    <label for="homophoneCount">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–º–æ—Ñ–æ–Ω–æ–≤ –Ω–∞ –±–∞–π—Ç:</label>
                    <select id="homophoneCount">
                        <option value="2">2 –æ–º–æ—Ñ–æ–Ω–∞ (1 –±–∏—Ç ID)</option>
                        <option value="4" selected>4 –æ–º–æ—Ñ–æ–Ω–∞ (2 –±–∏—Ç–∞ ID)</option>
                        <option value="8">8 –æ–º–æ—Ñ–æ–Ω–æ–≤ (3 –±–∏—Ç–∞ ID)</option>
                        <option value="16">16 –æ–º–æ—Ñ–æ–Ω–æ–≤ (4 –±–∏—Ç–∞ ID)</option>
                    </select>
                </div>
                
                <button class="btn-generate" onclick="generateNewKey()">
                    <span class="icon">üé≤</span> –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á
                </button>
            </div>

            <div class="card">
                <h2>üìù –ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</h2>
                <div class="input-group">
                    <label for="inputText">–¢–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                    <textarea id="inputText">–ü—Ä–∏–≤–µ—Ç –º–∏—Ä! Hello world! 123</textarea>
                </div>
                
                <div class="input-group">
                    <label>–ë–∞–π—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (HEX):</label>
                    <div class="hex-view" id="hexOriginal"></div>
                </div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">–†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö</div>
                        <div class="stat-value" id="dataSize">0 B</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">–≠–Ω—Ç—Ä–æ–ø–∏—è</div>
                        <div class="stat-value" id="dataEntropy">0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group">
            <button class="btn-encrypt" onclick="encryptData()">
                <span class="icon">üîí</span> –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
            </button>
            <button class="btn-decrypt" onclick="decryptData()">
                <span class="icon">üîì</span> –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
            </button>
        </div>

        <div class="card">
            <h2>üìä –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
            <div id="processVisualization" class="process-visualization">
                <div class="byte-block original-byte">
                    <div class="id-bits">ID: 00</div>
                    0x41
                </div>
                <div class="arrow">‚Üí</div>
                <div class="byte-block homophone-byte">
                    <div class="id-bits">ID: 10</div>
                    0xAB
                </div>
            </div>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">–†–∞–∑–º–µ—Ä –ø–æ—Å–ª–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</div>
                    <div class="stat-value" id="encryptedSize">0 B</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">–≠–Ω—Ç—Ä–æ–ø–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞</div>
                    <div class="stat-value" id="encryptedEntropy">0.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è</div>
                    <div class="stat-value" id="expansionRatio">0%</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üìã –†–µ–∑—É–ª—å—Ç–∞—Ç —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
                <div class="input-group">
                    <label for="outputText">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (HEX):</label>
                    <textarea id="outputText" readonly placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..."></textarea>
                </div>
                
                <div class="input-group">
                    <label>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–π—Ç–æ–≤:</label>
                    <div class="hex-view" id="hexOutput"></div>
                </div>
            </div>

            <div class="card">
                <h2>üîÑ –¢–∞–±–ª–∏—Ü–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</h2>
                <div class="input-group">
                    <label>–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–º–æ—Ñ–æ–Ω—ã (–ø–µ—Ä–≤—ã–µ 32 –±–∞–π—Ç–∞):</label>
                    <div class="byte-table" id="byteTablePreview">
                        <div class="byte-item">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    </div>
                </div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">–ë–∞–π—Ç–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü–µ</div>
                        <div class="stat-value" id="tableSize">256</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">–í—Å–µ–≥–æ –æ–º–æ—Ñ–æ–Ω–æ–≤</div>
                        <div class="stat-value" id="totalHomophones">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ByteHomophonicCipher {
            constructor() {
                this.homophoneTable = new Map();
            }

            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π PRNG –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
            createKeyDerivedRNG(key) {
                let seed = 0;
                const encoder = new TextEncoder();
                const keyBytes = encoder.encode(key);
                
                for (let i = 0; i < keyBytes.length; i++) {
                    seed = (seed << 5) - seed + keyBytes[i];
                    seed = seed & seed; // Convert to 32-bit integer
                }
                
                return {
                    next: () => {
                        seed = (seed * 1664525 + 1013904223) % 4294967296;
                        return seed / 4294967296;
                    }
                };
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤ –¥–ª—è –≤—Å–µ—Ö 256 –±–∞–π—Ç–æ–≤
            generateHomophoneTable(masterKey, homophonesPerByte = 4) {
                const table = new Map();
                const rng = this.createKeyDerivedRNG(masterKey);
                
                // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –±–∞–π—Ç–∞ (0-255)
                for (let byteValue = 0; byteValue < 256; byteValue++) {
                    const homophones = [];
                    
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ–º–æ—Ñ–æ–Ω—ã –¥–ª—è —ç—Ç–æ–≥–æ –±–∞–π—Ç–∞
                    for (let i = 0; i < homophonesPerByte; i++) {
                        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –æ–º–æ—Ñ–æ–Ω
                        let homophone;
                        let attempts = 0;
                        
                        do {
                            homophone = Math.floor(rng.next() * 256);
                            attempts++;
                        } while (homophones.includes(homophone) && attempts < 100);
                        
                        homophones.push(homophone);
                    }
                    
                    table.set(byteValue, homophones);
                }
                
                this.homophoneTable = table;
                return table;
            }

            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º ID –æ–º–æ—Ñ–æ–Ω–æ–≤
            encrypt(data, masterKey) {
                const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
                this.generateHomophoneTable(masterKey, homophonesPerByte);
                
                const rng = this.createKeyDerivedRNG(masterKey + data.length);
                const result = new Uint8Array(data.length * 2); // –ö–∞–∂–¥—ã–π –±–∞–π—Ç –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ 2 –±–∞–π—Ç–∞
                const processSteps = [];
                
                for (let i = 0; i < data.length; i++) {
                    const originalByte = data[i];
                    const homophones = this.homophoneTable.get(originalByte);
                    const homophoneIndex = Math.floor(rng.next() * homophones.length);
                    const selectedHomophone = homophones[homophoneIndex];
                    
                    // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–π –±–∞–π—Ç: –ø–µ—Ä–≤—ã–µ –±–∏—Ç—ã - ID, –æ—Å—Ç–∞–ª—å–Ω—ã–µ - –æ–º–æ—Ñ–æ–Ω
                    const idBits = homophoneIndex;
                    result[i * 2] = idBits; // ID –æ–º–æ—Ñ–æ–Ω–∞
                    result[i * 2 + 1] = selectedHomophone; // –°–∞–º –æ–º–æ—Ñ–æ–Ω
                    
                    processSteps.push({
                        original: originalByte,
                        homophone: selectedHomophone,
                        id: idBits,
                        idBits: idBits.toString(2).padStart(Math.ceil(Math.log2(homophones.length)), '0')
                    });
                }
                
                return { encryptedData: result, processSteps };
            }

            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            decrypt(encryptedData, masterKey) {
                const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
                this.generateHomophoneTable(masterKey, homophonesPerByte);
                
                const result = new Uint8Array(encryptedData.length / 2);
                
                for (let i = 0; i < encryptedData.length; i += 2) {
                    const idBits = encryptedData[i];
                    const homophoneByte = encryptedData[i + 1];
                    
                    // –ù–∞—Ö–æ–¥–∏–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±–∞–π—Ç –ø–æ ID –∏ –æ–º–æ—Ñ–æ–Ω—É
                    for (const [originalByte, homophones] of this.homophoneTable.entries()) {
                        if (idBits < homophones.length && homophones[idBits] === homophoneByte) {
                            result[i / 2] = originalByte;
                            break;
                        }
                    }
                }
                
                return result;
            }

            // –†–∞—Å—á–µ—Ç —ç–Ω—Ç—Ä–æ–ø–∏–∏ –¥–∞–Ω–Ω—ã—Ö
            calculateEntropy(data) {
                const freq = new Array(256).fill(0);
                for (const byte of data) {
                    freq[byte]++;
                }
                
                let entropy = 0;
                const length = data.length;
                
                for (const count of freq) {
                    if (count > 0) {
                        const p = count / length;
                        entropy -= p * Math.log2(p);
                    }
                }
                
                return entropy;
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        const cipher = new ByteHomophonicCipher();
        let lastProcessSteps = [];

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –∫–ª—é—á–∞
        function generateNewKey() {
            const randomBytes = new Uint8Array(16);
            crypto.getRandomValues(randomBytes);
            const key = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('masterKey').value = key;
            updateByteTable();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤
        function updateByteTable() {
            const masterKey = document.getElementById('masterKey').value;
            const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
            
            try {
                cipher.generateHomophoneTable(masterKey, homophonesPerByte);
                displayByteTablePreview();
            } catch (error) {
                console.error('Error generating homophone table:', error);
            }
        }

        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–µ–≤—å—é —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤
        function displayByteTablePreview() {
            const preview = document.getElementById('byteTablePreview');
            preview.innerHTML = '';
            
            const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
            let totalHomophones = 0;
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 32 –±–∞–π—Ç–∞ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
            for (let byteValue = 0; byteValue < 32; byteValue++) {
                const homophones = cipher.homophoneTable.get(byteValue) || [];
                totalHomophones += homophones.length;
                
                const item = document.createElement('div');
                item.className = 'byte-item';
                item.innerHTML = `
                    <span class="byte-value">0x${byteValue.toString(16).padStart(2, '0')}</span> ‚Üí 
                    ${homophones.map(b => `0x${b.toString(16).padStart(2, '0')}`).join(' ')}
                `;
                preview.appendChild(item);
            }
            
            document.getElementById('totalHomophones').textContent = 256 * homophonesPerByte;
        }

        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤ –≤ HEX-—Ñ–æ—Ä–º–∞—Ç–µ
        function displayHexData(data, elementId, className = '') {
            const container = document.getElementById(elementId);
            container.innerHTML = '';
            
            for (let i = 0; i < Math.min(data.length, 100); i++) {
                const byteElement = document.createElement('span');
                byteElement.className = `hex-byte ${className}`;
                byteElement.textContent = data[i].toString(16).padStart(2, '0');
                container.appendChild(byteElement);
            }
            
            if (data.length > 100) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = ` ... (–µ—â—ë ${data.length - 100} –±–∞–π—Ç)`;
                ellipsis.style.color = '#a0aec0';
                container.appendChild(ellipsis);
            }
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        function encryptData() {
            const inputText = document.getElementById('inputText').value;
            const masterKey = document.getElementById('masterKey').value;
            
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            if (!masterKey) {
                alert('–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á');
                return;
            }
            
            try {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –≤ –±–∞–π—Ç—ã
                const encoder = new TextEncoder();
                const data = encoder.encode(inputText);
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –±–∞–π—Ç—ã
                displayHexData(data, 'hexOriginal', 'original-hex');
                
                // –®–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
                const { encryptedData, processSteps } = cipher.encrypt(data, masterKey);
                lastProcessSteps = processSteps;
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                const outputHex = Array.from(encryptedData).map(b => b.toString(16).padStart(2, '0')).join(' ');
                document.getElementById('outputText').value = outputHex;
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–∞–π—Ç—ã
                displayHexData(encryptedData, 'hexOutput', 'homophone-hex');
                
                // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ—Ü–µ—Å—Å
                visualizeProcess();
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
                updateMetrics(data, encryptedData);
            } catch (error) {
                alert('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message);
            }
        }

        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        function decryptData() {
            const inputHex = document.getElementById('inputText').value.trim();
            const masterKey = document.getElementById('masterKey').value;
            
            if (!inputHex) {
                alert('–í–≤–µ–¥–∏—Ç–µ HEX-–¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }
            
            if (!masterKey) {
                alert('–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á');
                return;
            }
            
            try {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEX-—Å—Ç—Ä–æ–∫—É –≤ –±–∞–π—Ç—ã
                const hexBytes = inputHex.split(/\s+/);
                const encryptedData = new Uint8Array(hexBytes.map(byte => parseInt(byte, 16)));
                
                // –î–µ—à–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
                const decryptedData = cipher.decrypt(encryptedData, masterKey);
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –±–∞–π—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ç–µ–∫—Å—Ç
                const decoder = new TextDecoder();
                const decryptedText = decoder.decode(decryptedData);
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                document.getElementById('outputText').value = decryptedText;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
                updateMetrics(encryptedData, decryptedData);
            } catch (error) {
                alert('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message);
            }
        }

        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
        function visualizeProcess() {
            const container = document.getElementById('processVisualization');
            container.innerHTML = '';
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 8 –±–∞–π—Ç–æ–≤ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
            const stepsToShow = lastProcessSteps.slice(0, 8);
            
            stepsToShow.forEach((step, index) => {
                if (index > 0) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.textContent = '‚Üí';
                    container.appendChild(arrow);
                }
                
                const originalBlock = document.createElement('div');
                originalBlock.className = 'byte-block original-byte';
                originalBlock.innerHTML = `
                    <div class="id-bits">ID: ${step.idBits}</div>
                    0x${step.original.toString(16).padStart(2, '0')}
                `;
                container.appendChild(originalBlock);
                
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.textContent = '‚Üí';
                container.appendChild(arrow);
                
                const homophoneBlock = document.createElement('div');
                homophoneBlock.className = 'byte-block homophone-byte';
                homophoneBlock.innerHTML = `
                    <div class="id-bits">ID: ${step.idBits}</div>
                    0x${step.homophone.toString(16).padStart(2, '0')}
                `;
                container.appendChild(homophoneBlock);
            });
            
            if (lastProcessSteps.length > 8) {
                const ellipsis = document.createElement('div');
                ellipsis.style.cssText = 'padding: 10px; color: #a0aec0; font-style: italic;';
                ellipsis.textContent = `... –∏ –µ—â—ë ${lastProcessSteps.length - 8} –±–∞–π—Ç–æ–≤`;
                container.appendChild(ellipsis);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
        function updateMetrics(originalData, processedData) {
            if (originalData && processedData) {
                const originalSize = originalData.length;
                const processedSize = processedData.length;
                const expansion = ((processedSize - originalSize) / originalSize * 100).toFixed(1);
                
                document.getElementById('dataSize').textContent = originalSize + ' B';
                document.getElementById('encryptedSize').textContent = processedSize + ' B';
                document.getElementById('expansionRatio').textContent = expansion + '%';
                
                document.getElementById('dataEntropy').textContent = cipher.calculateEntropy(originalData).toFixed(2);
                document.getElementById('encryptedEntropy').textContent = cipher.calculateEntropy(processedData).toFixed(2);
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        window.onload = function() {
            generateNewKey();
            
            // –°–ª—É—à–∞—Ç–µ–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π
            document.getElementById('masterKey').addEventListener('input', updateByteTable);
            document.getElementById('homophoneCount').addEventListener('change', updateByteTable);
        };
    </script>
</body>
</html>
