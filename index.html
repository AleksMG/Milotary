<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–∞ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</title>
    <style>
        :root {
            --primary: #00ff8c;
            --secondary: #00994d;
            --dark: #0a1929;
            --darker: #07121d;
            --light: #142638;
            --text: #e6f7ff;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: var(--dark);
            color: var(--text);
            line-height: 1.6;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--darker);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 255, 140, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin: 0;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 10px rgba(0, 255, 140, 0.3);
        }
        
        .container {
            background: var(--darker);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(0, 255, 140, 0.1);
        }
        
        textarea, input {
            width: 100%;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 140, 0.2);
            background: var(--light);
            color: var(--text);
            font-family: 'Consolas', monospace;
            font-size: 16px;
            resize: vertical;
            transition: all 0.3s;
            box-sizing: border-box;
            margin-bottom: 15px;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(0, 255, 140, 0.2);
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
        }
        
        button {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--darker);
            box-shadow: 0 4px 15px rgba(0, 255, 140, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 140, 0.3);
        }
        
        .output {
            background: var(--light);
            padding: 20px;
            border-radius: 8px;
            margin-top: 15px;
            min-height: 100px;
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            border: 1px solid rgba(0, 255, 140, 0.1);
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: 600;
        }
        
        .success {
            background: rgba(0, 255, 140, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .error {
            background: rgba(255, 59, 48, 0.1);
            border: 1px solid #ff3b30;
            color: #ff3b30;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîê –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–∞ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</h1>
        <p>–ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω–∞—è –∞–ª–≥–µ–±—Ä–∞ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ Cl(3,1) –Ω–∞–¥ GF(2‚Å∏)</p>
    </div>
    
    <div class="container">
        <h2>üìù –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç</h2>
        <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è..." rows="5">–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</textarea>
        
        <h2>üîë –ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è (–º–∏–Ω–∏–º—É–º 16 —Å–∏–º–≤–æ–ª–æ–≤)</h2>
        <input type="password" id="encryptionKey" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–¥–µ–∂–Ω—ã–π –∫–ª—é—á" value="StrongPassword123!">
        
        <div class="btn-group">
            <button onclick="processEncryption()">üîÑ –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="processDecryption()">‚Ü©Ô∏è –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="clearAll()">‚ùå –û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
        
        <h2>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
        <div class="output" id="resultOutput">‚Äî</div>
        
        <div id="validationOutput" class="status">‚Äî</div>
    </div>

    <script>
        // –ü–æ–ª–Ω–æ—Ü–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ Cl(3,1) –Ω–∞–¥ GF(2‚Å∏)
        class RealCliffordCipher {
            constructor() {
                // –ê–ª–≥–µ–±—Ä–∞ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ Cl(3,1) - 3 –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö, 1 –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∏–∑–º–µ—Ä–µ–Ω–∏–µ
                this.dimension = 4;
                this.algebraSize = 1 << this.dimension; // 16 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                this.fieldSize = 256; // GF(2‚Å∏)
                this.rounds = 12;
                this.debugLog = [];
                
                // –¢–∞–±–ª–∏—Ü–∞ —É–º–Ω–æ–∂–µ–Ω–∏—è –¥–ª—è –±–∞–∑–∏—Å–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤
                // e‚ÇÅ¬≤ = e‚ÇÇ¬≤ = e‚ÇÉ¬≤ = 1, e‚ÇÑ¬≤ = -1
                // e_i * e_j = -e_j * e_i –¥–ª—è i ‚â† j
                this.metric = [1, 1, 1, -1]; // –°–∏–≥–Ω–∞—Ç—É—Ä–∞ (3,1)
                
                this.log(`‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –∞–ª–≥–µ–±—Ä–∞ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ Cl(3,1) –Ω–∞–¥ GF(${this.fieldSize})`);
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                this.debugLog.push({message: `[${timestamp}] ${message}`, type, time: Date.now()});
                return message;
            }

            // –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É–º–Ω–æ–∂–µ–Ω–∏–µ –≤ –∞–ª–≥–µ–±—Ä–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            cliffordMultiply(a, b) {
                let result = 0;
                let sign = 1;
                
                // –†–∞–∑–±–∏–≤–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –Ω–∞ –±–∞–∑–∏—Å–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã
                const aVectors = this.getBasisVectors(a);
                const bVectors = this.getBasisVectors(b);
                
                // –û–±—ä–µ–¥–∏–Ω—è–µ–º –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –≤–µ–∫—Ç–æ—Ä—ã —Å —É—á–µ—Ç–æ–º –∞–Ω—Ç–∏–∫–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏
                const allVectors = [...aVectors, ...bVectors];
                
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å —É—á–µ—Ç–æ–º –∑–Ω–∞–∫–∞ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏
                for (let i = 0; i < allVectors.length; i++) {
                    for (let j = i + 1; j < allVectors.length; j++) {
                        if (allVectors[i] > allVectors[j]) {
                            // –ú–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏ –∏ –º–µ–Ω—è–µ–º –∑–Ω–∞–∫
                            [allVectors[i], allVectors[j]] = [allVectors[j], allVectors[i]];
                            sign = -sign;
                        } else if (allVectors[i] === allVectors[j]) {
                            // e_i * e_i = g(e_i, e_i)
                            const square = this.metric[allVectors[i]];
                            if (square === -1) sign = -sign;
                            // –£–¥–∞–ª—è–µ–º –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –≤–µ–∫—Ç–æ—Ä—ã
                            allVectors.splice(j, 1);
                            allVectors.splice(i, 1);
                            i = Math.max(-1, i - 2);
                            j = i;
                            break;
                        }
                    }
                }
                
                // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                for (const vector of allVectors) {
                    result |= (1 << vector);
                }
                
                // –£–º–Ω–æ–∂–∞–µ–º –Ω–∞ –∑–Ω–∞–∫
                if (sign < 0) {
                    result = this.gfMultiply(result, this.fieldSize - 1);
                }
                
                return result;
            }

            // –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–∑–∏—Å–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏–∑ —ç–ª–µ–º–µ–Ω—Ç–∞
            getBasisVectors(element) {
                const vectors = [];
                for (let i = 0; i < this.dimension; i++) {
                    if (element & (1 << i)) {
                        vectors.push(i);
                    }
                }
                return vectors;
            }

            // –£–º–Ω–æ–∂–µ–Ω–∏–µ –≤ –ø–æ–ª–µ GF(2‚Å∏) —Å –Ω–µ–ø—Ä–∏–≤–æ–¥–∏–º—ã–º –ø–æ–ª–∏–Ω–æ–º–æ–º x‚Å∏ + x‚Å¥ + x¬≥ + x + 1
            gfMultiply(a, b) {
                let p = 0;
                let a_val = a;
                let b_val = b;
                
                for (let i = 0; i < 8; i++) {
                    if (b_val & 1) {
                        p ^= a_val;
                    }
                    
                    const hiBitSet = a_val & 0x80;
                    a_val <<= 1;
                    if (hiBitSet) {
                        a_val ^= 0x11B; // x‚Å∏ + x‚Å¥ + x¬≥ + x + 1
                    }
                    b_val >>= 1;
                }
                
                return p;
            }

            // –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ GF(2‚Å∏)
            gfInverse(a) {
                if (a === 0) return 0;
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞
                let t = 0, newt = 1;
                let r = 0x11B, newr = a;
                
                while (newr !== 0) {
                    const quotient = this.gfDivide(r, newr);
                    
                    [t, newt] = [newt, t ^ this.gfMultiply(quotient, newt)];
                    [r, newr] = [newr, r ^ this.gfMultiply(quotient, newr)];
                }
                
                if (r !== 1) return 0;
                return t;
            }

            // –î–µ–ª–µ–Ω–∏–µ –≤ GF(2‚Å∏)
            gfDivide(a, b) {
                if (b === 0) throw new Error("–î–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å");
                const bInv = this.gfInverse(b);
                return this.gfMultiply(a, bInv);
            }

            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –±–∞–π—Ç–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            encryptByte(byte, keyElement) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç –≤ —ç–ª–µ–º–µ–Ω—Ç –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
                const cliffordByte = byte % this.algebraSize;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ: C = K * P * K^(-1)
                const keyInverse = this.findInverse(keyElement);
                const kp = this.cliffordMultiply(keyElement, cliffordByte);
                const result = this.cliffordMultiply(kp, keyInverse);
                
                return result % this.fieldSize;
            }

            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –±–∞–π—Ç–∞
            decryptByte(byte, keyElement) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç –≤ —ç–ª–µ–º–µ–Ω—Ç –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
                const cliffordByte = byte % this.algebraSize;
                
                // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ: P = K^(-1) * C * K
                const keyInverse = this.findInverse(keyElement);
                const kInverseC = this.cliffordMultiply(keyInverse, cliffordByte);
                const result = this.cliffordMultiply(kInverseC, keyElement);
                
                return result % this.fieldSize;
            }

            // –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –∞–ª–≥–µ–±—Ä–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            findInverse(element) {
                // –î–ª—è –Ω–µ—Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞—Ö–æ–¥–∏–º –æ–±—Ä–∞—Ç–Ω—ã–π
                if (element === 0) return 0;
                
                // –ù–æ—Ä–º–∞ —ç–ª–µ–º–µ–Ω—Ç–∞: N(a) = a * √¢, –≥–¥–µ √¢ - –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ
                const conjugate = this.conjugate(element);
                const norm = this.cliffordMultiply(element, conjugate);
                
                // –û–±—Ä–∞—Ç–Ω—ã–π: a^(-1) = √¢ / N(a)
                const normInv = this.gfInverse(norm);
                return this.gfMultiply(conjugate, normInv);
            }

            // –û—Ç—Ä–∞–∂–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ (–≥—Ä–∞–¥—É–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–≤–æ–ª—é—Ü–∏—è)
            conjugate(element) {
                let result = 0;
                const vectors = this.getBasisVectors(element);
                
                // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –±–∞–∑–∏—Å–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –º–µ–Ω—è–µ–º –∑–Ω–∞–∫ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–µ–ø–µ–Ω–∏
                for (let i = 0; i < vectors.length; i++) {
                    const vector = vectors[i];
                    // –î–ª—è –Ω–µ—á–µ—Ç–Ω–æ–≥–æ —á–∏—Å–ª–∞ –≤–µ–∫—Ç–æ—Ä–æ–≤ –º–µ–Ω—è–µ–º –∑–Ω–∞–∫
                    if (vectors.length % 2 === 1) {
                        result |= (1 << vector);
                    }
                }
                
                return result;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª—é—á–µ–≤–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏–∑ —Å—Ç—Ä–æ–∫–∏
            createKeyElement(keyString) {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º SHA-256 –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Å—Ç–∏—á–µ—Å–∫–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
                let hash = 0;
                for (let i = 0; i < keyString.length; i++) {
                    hash = this.cliffordMultiply(hash, keyString.charCodeAt(i));
                    hash = (hash + i) % this.algebraSize;
                }
                return hash;
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            async encryptText(text, keyString) {
                this.debugLog = [];
                this.log('üöÄ –ù–∞—á–∞–ª–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞', 'success');
                
                if (keyString.length < 16) {
                    throw new Error('–ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 16 —Å–∏–º–≤–æ–ª–æ–≤');
                }
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–µ–∫—Å—Ç –≤ –±–∞–π—Ç—ã
                const textBytes = new TextEncoder().encode(text);
                this.log(`üìä –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: "${text}" (${textBytes.length} –±–∞–π—Ç)`);
                
                // –°–æ–∑–¥–∞–µ–º –∫–ª—é—á–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –ø–∞—Ä–æ–ª—è
                const keyElement = this.createKeyElement(keyString);
                this.log(`üîë –ö–ª—é—á–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç: ${keyElement}`);
                
                // –®–∏—Ñ—Ä—É–µ–º –∫–∞–∂–¥—ã–π –±–∞–π—Ç
                const encryptedBytes = new Uint8Array(textBytes.length);
                for (let i = 0; i < textBytes.length; i++) {
                    encryptedBytes[i] = this.encryptByte(textBytes[i], keyElement);
                    this.log(`üî¢ –ë–∞–π—Ç ${i}: ${textBytes[i]} ‚Üí ${encryptedBytes[i]}`);
                }
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ Base64 –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                const base64String = btoa(String.fromCharCode(...encryptedBytes));
                
                this.log('üéØ –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                
                return {
                    ciphertext: base64String,
                    debug: this.debugLog,
                    original: text
                };
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            async decryptText(ciphertext, keyString) {
                this.debugLog = [];
                this.log('üîì –ù–∞—á–∞–ª–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'success');
                
                // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∏–∑ Base64
                const encryptedBytes = new Uint8Array(
                    atob(ciphertext).split('').map(c => c.charCodeAt(0))
                );
                
                this.log(`üìä –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: ${encryptedBytes.length} –±–∞–π—Ç`);
                
                // –°–æ–∑–¥–∞–µ–º –∫–ª—é—á–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ –ø–∞—Ä–æ–ª—è
                const keyElement = this.createKeyElement(keyString);
                this.log(`üîë –ö–ª—é—á–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç: ${keyElement}`);
                
                // –î–µ—à–∏—Ñ—Ä—É–µ–º –∫–∞–∂–¥—ã–π –±–∞–π—Ç
                const decryptedBytes = new Uint8Array(encryptedBytes.length);
                for (let i = 0; i < encryptedBytes.length; i++) {
                    decryptedBytes[i] = this.decryptByte(encryptedBytes[i], keyElement);
                    this.log(`üî¢ –ë–∞–π—Ç ${i}: ${encryptedBytes[i]} ‚Üí ${decryptedBytes[i]}`);
                }
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ç–µ–∫—Å—Ç
                const text = new TextDecoder().decode(decryptedBytes);
                
                this.log('üéØ –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                
                return {
                    plaintext: text,
                    debug: this.debugLog
                };
            }
        }

        const cipher = new RealCliffordCipher();
        let lastResult = null;

        async function processEncryption() {
            try {
                const inputText = document.getElementById('inputText').value;
                const keyString = document.getElementById('encryptionKey').value;
                
                if (!inputText) {
                    alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }
                
                if (!keyString) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }

                const result = await cipher.encryptText(inputText, keyString);
                lastResult = result;

                // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                document.getElementById('resultOutput').textContent = 
                    `–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (Base64):\n${result.ciphertext}\n\n` +
                    `–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: ${result.original}\n` +
                    `–î–ª–∏–Ω–∞: ${result.ciphertext.length} —Å–∏–º–≤–æ–ª–æ–≤ Base64`;

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏
                document.getElementById('validationOutput').textContent = '‚úì –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('validationOutput').textContent = `‚úó –û—à–∏–±–∫–∞: ${error.message}`;
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        async function processDecryption() {
            try {
                const inputText = document.getElementById('inputText').value;
                const keyString = document.getElementById('encryptionKey').value;
                
                if (!inputText) {
                    alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }
                
                if (!keyString) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }

                const result = await cipher.decryptText(inputText, keyString);
                
                document.getElementById('resultOutput').textContent = 
                    `–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:\n${result.plaintext}\n\n` +
                    `–î–ª–∏–Ω–∞: ${result.plaintext.length} —Å–∏–º–≤–æ–ª–æ–≤`;
                
                document.getElementById('validationOutput').textContent = '‚úì –¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('validationOutput').textContent = `‚úó –û—à–∏–±–∫–∞: ${error.message}`;
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('encryptionKey').value = 'StrongPassword123!';
            document.getElementById('resultOutput').textContent = '‚Äî';
            document.getElementById('validationOutput').textContent = '‚Äî';
            document.getElementById('validationOutput').className = 'status';
            lastResult = null;
        }
    </script>
</body>
</html>
