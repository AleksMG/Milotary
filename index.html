<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0f0f23;
            color: #00ff00;
            line-height: 1.6;
        }
        .container {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            background: rgba(0, 255, 0, 0.05);
        }
        h1, h2 {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00ff00;
        }
        textarea {
            width: 100%;
            height: 100px;
            background: #1c1c1c;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px;
            font-family: monospace;
            border-radius: 4px;
            resize: vertical;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 12px 24px;
            margin: 10px 5px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 10px #00ff00;
        }
        .output {
            background: #1c1c1c;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #00ff00;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }
        .debug {
            background: #2a2a2a;
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid #ff9900;
            border-radius: 3px;
        }
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .warning { color: #ff9900; }
        .info { color: #00ccff; }
        .flex-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .status {
            padding: 10px;
            text-align: center;
            font-weight: bold;
            border-radius: 4px;
            margin: 10px 0;
        }
        .valid {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
        }
        .invalid {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
        }
        .key-display {
            font-family: monospace;
            background: #1c1c1c;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <h1>üîê –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</h1>

    <div class="container">
        <h2>üìù –ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</h2>
        <textarea id="inputText">–ü—Ä–∏–≤–µ—Ç –º–∏—Ä! –¢–µ—Å—Ç–∏—Ä—É–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ.</textarea>
        <div class="flex-row">
            <button onclick="processEncryption()">üîÑ –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="processDecryption()">‚Ü©Ô∏è –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="clearAll()">‚ùå –û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
    </div>

    <div class="container">
        <h2>üîß –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∏—Å—Ç–µ–º—ã</h2>
        <div class="debug">
            <strong>–ê–ª–≥–µ–±—Ä–∞ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</strong><br>
            ‚Ä¢ –†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å: 8<br>
            ‚Ä¢ –£—Ä–æ–≤–Ω–µ–π —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: 3<br>
            ‚Ä¢ –ú–µ—Ç–æ–¥: –º–∞—Ç—Ä–∏—á–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞<br>
            ‚Ä¢ –û—Å–Ω–æ–≤–∞: –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
        </div>
    </div>

    <div class="container">
        <h2>üßÆ –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è/–¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
        <div class="output" id="processOutput">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
    </div>

    <div class="container">
        <h2>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
        <div class="output" id="resultOutput">‚Äî</div>
        <div id="validationOutput" class="status">‚Äî</div>
    </div>

    <script>
        class TextCliffordCipher {
            constructor() {
                this.dimension = 8;
                this.levels = 3;
                this.debugLog = [];
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                this.debugLog.push({message: `[${timestamp}] ${message}`, type, time: Date.now()});
                return message;
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—Å—Ç–∞
            generateKey(text) {
                let key = 0;
                for (let i = 0; i < text.length; i++) {
                    key = (key + text.charCodeAt(i) * (i + 1)) % 65536;
                }
                this.log(`üîë –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–ª—é—á –∏–∑ —Ç–µ–∫—Å—Ç–∞: ${key}`);
                return key;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            createCliffordMatrix(key, size) {
                const matrix = [];
                for (let i = 0; i < size; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < size; j++) {
                        // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Å—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Ç—Ä–∏—Ü—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                        const value = Math.sin(key * (i + 1) + key * (j + 1)) * 1000;
                        matrix[i][j] = Math.abs(Math.floor(value) % 256);
                    }
                }
                return matrix;
            }

            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ –∫ —Ç–µ–∫—Å—Ç—É
            applyCliffordTransformation(text, matrix) {
                let result = '';
                const matrixSize = matrix.length;
                
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i);
                    let transformedCode = 0;
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∞—Ç—Ä–∏—á–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
                    for (let j = 0; j < matrixSize; j++) {
                        if (j < text.length) {
                            const otherCharCode = text.charCodeAt((i + j) % text.length);
                            transformedCode += matrix[i % matrixSize][j] * otherCharCode;
                        }
                    }
                    
                    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∏ –¥–æ–±–∞–≤–ª—è–µ–º –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
                    transformedCode = Math.abs(transformedCode) % 65536;
                    if (transformedCode < 32) transformedCode += 32; // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —ç—Ç–æ –ø–µ—á–∞—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª
                    result += String.fromCharCode(transformedCode);
                }
                
                return result;
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            encryptText(text) {
                this.debugLog = [];
                this.log('üöÄ –ù–∞—á–∞–ª–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞', 'success');
                
                const key = this.generateKey(text);
                const matrix = this.createCliffordMatrix(key, this.dimension);
                
                this.log(`üìä –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: "${text}" (${text.length} —Å–∏–º–≤–æ–ª–æ–≤)`);
                this.log(`üìê –ú–∞—Ç—Ä–∏—Ü–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è: ${JSON.stringify(matrix)}`);

                let transformedText = text;
                
                // –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
                for (let level = 0; level < this.levels; level++) {
                    this.log(`\nüî¢ –£—Ä–æ–≤–µ–Ω—å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è ${level + 1}/${this.levels}`, 'warning');
                    transformedText = this.applyCliffordTransformation(transformedText, matrix);
                    this.log(`üìÑ –¢–µ–∫—Å—Ç –ø–æ—Å–ª–µ —É—Ä–æ–≤–Ω—è ${level + 1}: "${transformedText}"`);
                }

                this.log('\nüéØ –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                return {
                    ciphertext: transformedText,
                    debug: this.debugLog,
                    original: text,
                    key: key
                };
            }

            // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            reverseCliffordTransformation(text, matrix) {
                let result = '';
                const matrixSize = matrix.length;
                const matrixDet = this.matrixDeterminant(matrix);
                
                // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—Ä–∞—Ç–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥)
                if (matrixDet !== 0) {
                    for (let i = 0; i < text.length; i++) {
                        const charCode = text.charCodeAt(i);
                        let reversedCode = 0;
                        
                        for (let j = 0; j < matrixSize; j++) {
                            if (j < text.length) {
                                const otherCharCode = text.charCodeAt((i + j) % text.length);
                                reversedCode += matrix[j][i % matrixSize] * otherCharCode;
                            }
                        }
                        
                        reversedCode = Math.abs(reversedCode) % 65536;
                        if (reversedCode < 32) reversedCode += 32;
                        result += String.fromCharCode(reversedCode);
                    }
                } else {
                    // –ï—Å–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—å –Ω—É–ª–µ–≤–æ–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥
                    result = this.alternativeDecryption(text, matrix);
                }
                
                return result;
            }

            // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            alternativeDecryption(text, matrix) {
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i);
                    // –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –æ–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                    let reversedCode = (charCode - matrix[i % matrix.length][0] + 65536) % 65536;
                    if (reversedCode < 32) reversedCode += 32;
                    result += String.fromCharCode(reversedCode);
                }
                return result;
            }

            // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ–ª—è –º–∞—Ç—Ä–∏—Ü—ã (—É–ø—Ä–æ—â–µ–Ω–Ω–æ–µ)
            matrixDeterminant(matrix) {
                if (matrix.length === 2) {
                    return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
                }
                let det = 0;
                for (let i = 0; i < matrix.length; i++) {
                    det += matrix[0][i] * (i % 2 === 0 ? 1 : -1);
                }
                return det;
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            decryptText(ciphertext, originalText) {
                this.debugLog = [];
                this.log('üîì –ù–∞—á–∞–ª–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞', 'success');
                
                const key = this.generateKey(originalText);
                const matrix = this.createCliffordMatrix(key, this.dimension);
                
                this.log(`üìä –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: "${ciphertext}" (${ciphertext.length} —Å–∏–º–≤–æ–ª–æ–≤)`);
                this.log(`üìê –ú–∞—Ç—Ä–∏—Ü–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è: ${JSON.stringify(matrix)}`);

                let decryptedText = ciphertext;
                
                // –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ (–≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ)
                for (let level = this.levels - 1; level >= 0; level--) {
                    this.log(`\nüî¢ –£—Ä–æ–≤–µ–Ω—å –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è ${this.levels - level}/${this.levels}`, 'warning');
                    decryptedText = this.reverseCliffordTransformation(decryptedText, matrix);
                    this.log(`üìÑ –¢–µ–∫—Å—Ç –ø–æ—Å–ª–µ —É—Ä–æ–≤–Ω—è ${this.levels - level}: "${decryptedText}"`);
                }

                this.log('\nüéØ –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                return {
                    plaintext: decryptedText,
                    debug: this.debugLog
                };
            }
        }

        const cipher = new TextCliffordCipher();
        let lastResult = null;

        function processEncryption() {
            const inputText = document.getElementById('inputText').value;
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }

            const result = cipher.encryptText(inputText);
            lastResult = result;

            // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞
            const processOutput = result.debug.map(item => 
                `<span class="${item.type}">${item.message}</span>`
            ).join('\n');
            
            document.getElementById('processOutput').innerHTML = processOutput;
            
            // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            document.getElementById('resultOutput').innerHTML = 
                `üì¶ –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: "${result.ciphertext}"\n\n` +
                `üìÑ –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: "${result.original}"\n` +
                `üî¢ –î–ª–∏–Ω–∞: ${result.ciphertext.length} —Å–∏–º–≤–æ–ª–æ–≤\n` +
                `üîë –ö–ª—é—á: ${result.key}`;

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏
            document.getElementById('validationOutput').textContent = '‚úì –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ';
            document.getElementById('validationOutput').className = 'status valid';
        }

        function processDecryption() {
            if (!lastResult) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞—à–∏—Ñ—Ä—É–π—Ç–µ —Ç–µ–∫—Å—Ç');
                return;
            }

            const inputText = document.getElementById('inputText').value;
            const result = cipher.decryptText(lastResult.ciphertext, inputText);
            
            document.getElementById('processOutput').innerHTML = 
                result.debug.map(item => `<span class="${item.type}">${item.message}</span>`).join('\n');
            
            const isMatch = result.plaintext === inputText;
            document.getElementById('resultOutput').innerHTML = 
                `üìÑ –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: "${result.plaintext}"\n\n` +
                `‚úÖ –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Å –∏—Å—Ö–æ–¥–Ω—ã–º: ${isMatch ? '–î–ê' : '–ù–ï–¢'}`;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
            document.getElementById('validationOutput').textContent = isMatch ? 
                '‚úì –¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω' : '‚úó –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏';
            document.getElementById('validationOutput').className = isMatch ? 'status valid' : 'status invalid';
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('processOutput').innerHTML = '–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...';
            document.getElementById('resultOutput').innerHTML = '‚Äî';
            document.getElementById('validationOutput').textContent = '‚Äî';
            document.getElementById('validationOutput').className = 'status';
            lastResult = null;
        }
    </script>
</body>
</html>
