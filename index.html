<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–£—Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤–æ–≤–∞–Ω–Ω–∞—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞ –Ω–∞ –∞–ª–≥–µ–±—Ä–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</title>
    <style>
        :root {
            --primary: #00ff8c;
            --primary-dark: #00cc70;
            --secondary: #00994d;
            --dark: #0a1929;
            --darker: #07121d;
            --light: #142638;
            --text: #e6f7ff;
            --error: #ff6b6b;
            --warning: #ffd93d;
            --success: #6bff8c;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: var(--dark);
            color: var(--text);
            line-height: 1.6;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--darker);
            border-radius: 16px;
            box-shadow: 0 6px 25px rgba(0, 255, 140, 0.15);
            border: 1px solid rgba(0, 255, 140, 0.1);
        }
        
        h1 {
            font-size: 2.8rem;
            margin: 0 0 10px 0;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 15px rgba(0, 255, 140, 0.25);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .container {
            background: var(--darker);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(0, 255, 140, 0.1);
        }
        
        .panel {
            margin-bottom: 25px;
        }
        
        .panel-title {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        textarea, input {
            width: 100%;
            padding: 16px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 140, 0.2);
            background: var(--light);
            color: var(--text);
            font-family: 'Consolas', monospace;
            font-size: 16px;
            resize: vertical;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }
        
        textarea:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 255, 140, 0.2);
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 16px 32px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: var(--darker);
            box-shadow: 0 5px 15px rgba(0, 255, 140, 0.25);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 140, 0.35);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button.secondary {
            background: transparent;
            color: var(--primary);
            border: 1px solid var(--primary);
        }
        
        .output {
            background: var(--light);
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            min-height: 100px;
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            border: 1px solid rgba(0, 255, 140, 0.1);
        }
        
        .status {
            padding: 16px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .success {
            background: rgba(0, 255, 140, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .error {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
        }
        
        .warning {
            background: rgba(255, 217, 61, 0.1);
            border: 1px solid var(--warning);
            color: var(--warning);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .debug {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 14px;
        }
        
        .debug-entry {
            padding: 10px;
            border-bottom: 1px solid rgba(0, 255, 140, 0.1);
            font-family: 'Consolas', monospace;
        }
        
        .debug-info {
            color: var(--primary);
        }
        
        .debug-error {
            color: var(--error);
        }
        
        .debug-warning {
            color: var(--warning);
        }
        
        .explanation {
            background: rgba(0, 167, 255, 0.1);
            border: 1px solid #00a7ff;
            color: #00a7ff;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
        }
        
        .math {
            font-family: 'Cambria Math', serif;
            font-style: italic;
        }
        
        .key-strength {
            height: 8px;
            background: var(--light);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .key-strength-fill {
            height: 100%;
            width: 0%;
            background: var(--primary);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .key-info {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 14px;
        }
        
        .flex-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .flex-col {
            flex: 1;
        }
        
        @media (max-width: 768px) {
            .flex-row {
                flex-direction: column;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
        
        .crypto-details {
            background: rgba(0, 255, 140, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid rgba(0, 255, 140, 0.1);
        }
        
        .details-title {
            font-weight: bold;
            color: var(--primary);
            margin-bottom: 8px;
        }
        
        .key-visualization {
            margin-top: 20px;
            padding: 15px;
            background: var(--light);
            border-radius: 10px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîê –£—Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤–æ–≤–∞–Ω–Ω–∞—è –∫—Ä–∏–ø—Ç–æ—Å–∏—Å—Ç–µ–º–∞ –Ω–∞ –∞–ª–≥–µ–±—Ä–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</h1>
        <p class="subtitle">–ü–æ–ª–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∫–ª—é—á–µ–π –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç–∏</p>
    </div>
    
    <div class="container">
        <div class="warning">
            <h3>‚ö†Ô∏è –£–ª—É—á—à–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</h3>
            <p>–í –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–ª—é—á —Å–≤–æ–¥–∏–ª—Å—è –∫ –ø—Ä–æ—Å—Ç–æ–º—É 3-–∑–Ω–∞—á–Ω–æ–º—É —á–∏—Å–ª—É, —á—Ç–æ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —Å–Ω–∏–∂–∞–ª–æ –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç—å. –í —ç—Ç–æ–π –≤–µ—Ä—Å–∏–∏:</p>
            <ul>
                <li>–ü–æ–ª–Ω–æ—Å—Ç—å—é –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∫–ª—é—á–µ–π —Å –ø–æ–º–æ—â—å—é —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è SHA-256</li>
                <li>–ö–ª—é—á –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç—Å—è –≤ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ —Å–∫–∞–ª—è—Ä–Ω—É—é —á–∞—Å—Ç—å</li>
                <li>–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞–º–∏ —Å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π —ç–Ω—Ç—Ä–æ–ø–∏–∏</li>
                <li>–î–æ–±–∞–≤–ª–µ–Ω–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –∫—Ä–∏–ø—Ç–æ–∞–Ω–∞–ª–∏–∑–∞</li>
            </ul>
        </div>
        
        <div class="explanation">
            <h3>–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Å–Ω–æ–≤–∞ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏</h3>
            <p>–î–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏ –≤ –∞–ª–≥–µ–±—Ä–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ:</p>
            <p class="math">C = K * P * K‚Åª¬π</p>
            <p>–≥–¥–µ K‚Åª¬π ‚Äî –æ–±—Ä–∞—Ç–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –∫ K. –î–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</p>
            <p class="math">P = K‚Åª¬π * C * K</p>
            <p>–ö–ª—é—á K —Ç–µ–ø–µ—Ä—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä, —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–∑ —Ö–µ—à–∞ SHA-256, —á—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–æ–ª–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∫–ª—é—á–µ–π.</p>
        </div>
        
        <div class="flex-row">
            <div class="flex-col">
                <div class="panel">
                    <h2 class="panel-title">üìù –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç</h2>
                    <textarea id="inputText" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è..." rows="6">–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ —Å –ø–æ–ª–Ω—ã–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∫–ª—é—á–µ–π</textarea>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title">üîë –ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
                    <input type="password" id="encryptionKey" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–¥–µ–∂–Ω—ã–π –∫–ª—é—á (–º–∏–Ω–∏–º—É–º 16 —Å–∏–º–≤–æ–ª–æ–≤)" value="VeryStrongPassword123!@#">
                    
                    <div class="key-strength">
                        <div class="key-strength-fill" id="keyStrengthBar"></div>
                    </div>
                    <div class="key-info">
                        <span id="keyStrengthText">–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å –∫–ª—é—á–∞: –Ω–µ –æ—Ü–µ–Ω–µ–Ω–∞</span>
                        <span id="keyEntropy">–≠–Ω—Ç—Ä–æ–ø–∏—è: 0 –±–∏—Ç</span>
                    </div>
                    
                    <div class="key-visualization" id="keyVisualization">
                        –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª—é—á–∞ –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å –ø–æ—Å–ª–µ –≤–≤–æ–¥–∞...
                    </div>
                </div>
            </div>
            
            <div class="flex-col">
                <div class="panel">
                    <h2 class="panel-title">‚öôÔ∏è –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</h2>
                    
                    <div class="crypto-details">
                        <div class="details-title">–ê–ª–≥–æ—Ä–∏—Ç–º —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è:</div>
                        <div>SHA-256 (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –∫–ª—é—á–∞)</div>
                    </div>
                    
                    <div class="crypto-details">
                        <div class="details-title">–†–∞–∑–º–µ—Ä –∫–ª—é—á–∞:</div>
                        <div>256 –±–∏—Ç (32 –±–∞–π—Ç–∞) –ø–æ—Å–ª–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è</div>
                    </div>
                    
                    <div class="crypto-details">
                        <div class="details-title">–ê–ª–≥–µ–±—Ä–∞:</div>
                        <div>Cl(3,1) —Å 16 –±–∞–∑–∏—Å–Ω—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏</div>
                    </div>
                    
                    <label>
                        <input type="checkbox" id="addSalt" checked>
                        –î–æ–±–∞–≤–ª—è—Ç—å –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫—É—é —Å–æ–ª—å
                    </label>
                    
                    <label>
                        <input type="checkbox" id="useKDF" checked>
                        –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Key Derivation Function (KDF)
                    </label>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title">üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
                    <div class="output" id="resultOutput">‚Äî</div>
                    
                    <div id="validationOutput" class="status">‚Äî</div>
                </div>
            </div>
        </div>
        
        <div class="btn-group">
            <button onclick="processEncryption()"><span>üîÑ</span> –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="processDecryption()"><span>‚Ü©Ô∏è</span> –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="generateStrongKey()"><span>üé≤</span> –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á</button>
            <button onclick="testReversibility()"><span>üß™</span> –¢–µ—Å—Ç –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏</button>
            <button class="secondary" onclick="clearAll()"><span>‚ùå</span> –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ</button>
        </div>
        
        <div class="panel">
            <h2 class="panel-title">üîç –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</h2>
            <div class="output debug" id="debugOutput">‚Äî</div>
        </div>
    </div>

    <script>
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è SHA-256 (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏)
        // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ —Å–ª–µ–¥—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å window.crypto.subtle.digest
        class SHA256 {
            constructor() {
                this.K = [
                    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
                    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
                    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
                    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
                    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
                    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
                ];
                
                this.H = [
                    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                ];
            }
            
            // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
            rightRotate(value, amount) {
                return (value >>> amount) | (value << (32 - amount));
            }
            
            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
            async hash(message) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –º–∞—Å—Å–∏–≤ –±–∞–π—Ç
                const msgBuffer = new TextEncoder().encode(message);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –±–∏—Ç '1' –≤ –∫–æ–Ω–µ—Ü —Å–æ–æ–±—â–µ–Ω–∏—è
                const msgBitLength = msgBuffer.length * 8;
                const blockCount = (((msgBitLength + 64) >> 9) << 4) + 16;
                const msg = new Uint8Array(blockCount * 4);
                
                msg.set(msgBuffer);
                msg[msgBuffer.length] = 0x80; // –î–æ–±–∞–≤–ª—è–µ–º 1 –±–∏—Ç
                
                // –î–æ–±–∞–≤–ª—è–µ–º –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –±–∏—Ç–∞—Ö
                const lenPos = msg.length - 4;
                msg[lenPos] = (msgBitLength >>> 24) & 0xff;
                msg[lenPos + 1] = (msgBitLength >>> 16) & 0xff;
                msg[lenPos + 2] = (msgBitLength >>> 8) & 0xff;
                msg[lenPos + 3] = msgBitLength & 0xff;
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ö–µ—à-–∑–Ω–∞—á–µ–Ω–∏–π
                let h0 = this.H[0], h1 = this.H[1], h2 = this.H[2], h3 = this.H[3];
                let h4 = this.H[4], h5 = this.H[5], h6 = this.H[6], h7 = this.H[7];
                
                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –±–ª–æ–∫–∞–º–∏ –ø–æ 512 –±–∏—Ç
                for (let i = 0; i < msg.length; i += 64) {
                    const w = new Array(64);
                    
                    // –†–∞–∑–±–∏–≤–∞–µ–º –±–ª–æ–∫ –Ω–∞ 16 —Å–ª–æ–≤ –ø–æ 32 –±–∏—Ç–∞
                    for (let j = 0; j < 16; j++) {
                        const pos = i + j * 4;
                        w[j] = (msg[pos] << 24) | (msg[pos + 1] << 16) | 
                               (msg[pos + 2] << 8) | msg[pos + 3];
                    }
                    
                    // –†–∞—Å—à–∏—Ä—è–µ–º 16 —Å–ª–æ–≤ –≤ 64 —Å–ª–æ–≤–∞
                    for (let j = 16; j < 64; j++) {
                        const s0 = this.rightRotate(w[j-15], 7) ^ this.rightRotate(w[j-15], 18) ^ (w[j-15] >>> 3);
                        const s1 = this.rightRotate(w[j-2], 17) ^ this.rightRotate(w[j-2], 19) ^ (w[j-2] >>> 10);
                        w[j] = (w[j-16] + s0 + w[j-7] + s1) & 0xffffffff;
                    }
                    
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—á–∏—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
                    let a = h0, b = h1, c = h2, d = h3;
                    let e = h4, f = h5, g = h6, h = h7;
                    
                    // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Å–∂–∞—Ç–∏—è
                    for (let j = 0; j < 64; j++) {
                        const S1 = this.rightRotate(e, 6) ^ this.rightRotate(e, 11) ^ this.rightRotate(e, 25);
                        const ch = (e & f) ^ ((~e) & g);
                        const temp1 = (h + S1 + ch + this.K[j] + w[j]) & 0xffffffff;
                        const S0 = this.rightRotate(a, 2) ^ this.rightRotate(a, 13) ^ this.rightRotate(a, 22);
                        const maj = (a & b) ^ (a & c) ^ (b & c);
                        const temp2 = (S0 + maj) & 0xffffffff;
                        
                        h = g;
                        g = f;
                        f = e;
                        e = (d + temp1) & 0xffffffff;
                        d = c;
                        c = b;
                        b = a;
                        a = (temp1 + temp2) & 0xffffffff;
                    }
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º —Å–∂–∞—Ç—ã–π –±–ª–æ–∫ –∫ —Ç–µ–∫—É—â–µ–º—É —Ö–µ—à-–∑–Ω–∞—á–µ–Ω–∏—é
                    h0 = (h0 + a) & 0xffffffff;
                    h1 = (h1 + b) & 0xffffffff;
                    h2 = (h2 + c) & 0xffffffff;
                    h3 = (h3 + d) & 0xffffffff;
                    h4 = (h4 + e) & 0xffffffff;
                    h5 = (h5 + f) & 0xffffffff;
                    h6 = (h6 + g) & 0xffffffff;
                    h7 = (h7 + h) & 0xffffffff;
                }
                
                // –§–æ—Ä–º–∏—Ä—É–µ–º –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π —Ö–µ—à
                const hash = [
                    h0, h1, h2, h3, h4, h5, h6, h7
                ];
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ hex-—Å—Ç—Ä–æ–∫—É
                let hexHash = '';
                for (let i = 0; i < hash.length; i++) {
                    hexHash += ('00000000' + hash[i].toString(16)).slice(-8);
                }
                
                return hexHash;
            }
        }

        // –£—Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤–æ–≤–∞–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ Cl(3,1)
        class EnhancedCliffordAlgebra {
            constructor() {
                this.dimension = 4;
                this.metric = [1, 1, 1, -1]; // –°–∏–≥–Ω–∞—Ç—É—Ä–∞ (3,1)
                this.basisCount = 16; // 2^4 = 16 –±–∞–∑–∏—Å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                
                // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≤—ã—á–∏—Å–ª–µ–Ω–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ —É–º–Ω–æ–∂–µ–Ω–∏—è
                this.multiplicationTable = this.generateMultiplicationTable();
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã —É–º–Ω–æ–∂–µ–Ω–∏—è –¥–ª—è –±–∞–∑–∏—Å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            generateMultiplicationTable() {
                const table = new Array(this.basisCount);
                for (let i = 0; i < this.basisCount; i++) {
                    table[i] = new Array(this.basisCount);
                    for (let j = 0; j < this.basisCount; j++) {
                        table[i][j] = this.multiplyBasisElements(i, j);
                    }
                }
                return table;
            }
            
            // –£–º–Ω–æ–∂–µ–Ω–∏–µ –¥–≤—É—Ö –±–∞–∑–∏—Å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            multiplyBasisElements(a, b) {
                if (a === 0) return { value: b, sign: 1 };
                if (b === 0) return { value: a, sign: 1 };
                
                const aVectors = this.getBasisVectors(a);
                const bVectors = this.getBasisVectors(b);
                
                let resultVectors = [...aVectors];
                let sign = 1;
                
                // –î–æ–±–∞–≤–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä—ã –∏–∑ b —Å —É—á–µ—Ç–æ–º –∞–Ω—Ç–∏–∫–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏
                for (const bVec of bVectors) {
                    let insertPos = resultVectors.length;
                    
                    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ —Å —É—á–µ—Ç–æ–º –ø–æ—Ä—è–¥–∫–∞
                    for (let i = 0; i < resultVectors.length; i++) {
                        if (resultVectors[i] === bVec) {
                            // –ù–∞–π–¥–µ–Ω –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π –≤–µ–∫—Ç–æ—Ä - –ø—Ä–∏–º–µ–Ω—è–µ–º –∫–≤–∞–¥—Ä–∞—Ç
                            sign *= this.metric[bVec];
                            resultVectors.splice(i, 1);
                            insertPos = -1;
                            break;
                        } else if (resultVectors[i] > bVec) {
                            insertPos = i;
                            break;
                        }
                    }
                    
                    if (insertPos >= 0) {
                        // –í—Å—Ç–∞–≤–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä –∏ —É—á–∏—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏
                        sign *= Math.pow(-1, resultVectors.length - insertPos);
                        resultVectors.splice(insertPos, 0, bVec);
                    }
                }
                
                // –°–æ–±–∏—Ä–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                let resultValue = 0;
                for (const vec of resultVectors) {
                    resultValue |= (1 << vec);
                }
                
                return { value: resultValue, sign: sign };
            }
            
            // –ü–æ–ª—É—á–∏—Ç—å –º–∞—Å—Å–∏–≤ –∏–Ω–¥–µ–∫—Å–æ–≤ –±–∞–∑–∏—Å–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏–∑ —á–∏—Å–ª–∞
            getBasisVectors(x) {
                const vectors = [];
                for (let i = 0; i < this.dimension; i++) {
                    if (x & (1 << i)) {
                        vectors.push(i);
                    }
                }
                return vectors.sort((a, b) => a - b);
            }
            
            // –£–º–Ω–æ–∂–µ–Ω–∏–µ –¥–≤—É—Ö –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–æ–≤
            multiply(a, b) {
                const result = new Array(this.basisCount).fill(0);
                
                for (let i = 0; i < this.basisCount; i++) {
                    if (Math.abs(a[i]) < 1e-10) continue;
                    
                    for (let j = 0; j < this.basisCount; j++) {
                        if (Math.abs(b[j]) < 1e-10) continue;
                        
                        const product = this.multiplicationTable[i][j];
                        const coefficient = a[i] * b[j] * product.sign;
                        result[product.value] = (result[product.value] || 0) + coefficient;
                    }
                }
                
                return result;
            }
            
            // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
            inverse(mv) {
                // –î–ª—è –ø–æ–ª–Ω–æ–≥–æ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–∞ –≤—ã—á–∏—Å–ª—è–µ–º –æ–±—Ä–∞—Ç–Ω—ã–π —á–µ—Ä–µ–∑ —Å–æ–ø—Ä—è–∂–µ–Ω–∏–µ –∏ –Ω–æ—Ä–º—É
                const reversed = this.reverse(mv);
                const norm = this.multiply(mv, reversed);
                
                // –ù–æ—Ä–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–∫–∞–ª—è—Ä–æ–º
                if (Math.abs(norm[0]) < 1e-10) {
                    throw new Error("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–±—Ä–∞—Ç–∏—Ç—å –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä —Å –Ω—É–ª–µ–≤–æ–π –Ω–æ—Ä–º–æ–π");
                }
                
                const result = new Array(this.basisCount).fill(0);
                for (let i = 0; i < this.basisCount; i++) {
                    result[i] = reversed[i] / norm[0];
                }
                
                return result;
            }
            
            // –°–æ–ø—Ä—è–∂–µ–Ω–∏–µ (—Ä–µ–≤–µ—Ä—Å) –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–∞
            reverse(mv) {
                const result = [...mv];
                // –î–ª—è Cl(3,1) —Ä–µ–≤–µ—Ä—Å –º–µ–Ω—è–µ—Ç –∑–Ω–∞–∫ —É —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –Ω–µ—á–µ—Ç–Ω–æ–π —Å—Ç–µ–ø–µ–Ω—å—é
                for (let i = 1; i < this.basisCount; i++) {
                    const vectors = this.getBasisVectors(i);
                    if (vectors.length % 2 === 1) {
                        result[i] = -result[i];
                    }
                }
                return result;
            }
            
            // –ù–æ—Ä–º–∞ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–∞
            norm(mv) {
                const reversed = this.reverse(mv);
                return this.multiply(mv, reversed);
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–∞ –∏–∑ —Ö–µ—à–∞
            multivectorFromHash(hash) {
                const mv = new Array(this.basisCount).fill(0);
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ö–µ—à –≤ –±–∞–π—Ç—ã
                const hashBytes = [];
                for (let i = 0; i < hash.length; i += 2) {
                    hashBytes.push(parseInt(hash.substr(i, 2), 16));
                }
                
                // –ó–∞–ø–æ–ª–Ω—è–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–∞
                for (let i = 0; i < this.basisCount && i < hashBytes.length; i++) {
                    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-1, 1]
                    mv[i] = (hashBytes[i] / 128) - 1;
                }
                
                return mv;
            }
        }

        // –£—Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤–æ–≤–∞–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —à–∏—Ñ—Ä–∞ —Å –ø–æ–ª–Ω—ã–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–ª—é—á–µ–≤–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
        class EnhancedCliffordCipher {
            constructor() {
                this.algebra = new EnhancedCliffordAlgebra();
                this.fieldSize = 256; // GF(2‚Å∏)
                this.debugLog = [];
                this.sha256 = new SHA256();
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                this.debugLog.push({message: `[${timestamp}] ${message}`, type});
                
                const debugOutput = document.getElementById('debugOutput');
                if (debugOutput) {
                    const entry = document.createElement('div');
                    entry.className = `debug-entry debug-${type}`;
                    entry.textContent = `[${timestamp}] ${message}`;
                    debugOutput.appendChild(entry);
                    debugOutput.scrollTop = debugOutput.scrollHeight;
                }
                
                return message;
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –≤ –±–∞–π—Ç—ã
            stringToBytes(str) {
                return new TextEncoder().encode(str);
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–æ–≤ –≤ —Å—Ç—Ä–æ–∫—É
            bytesToString(bytes) {
                return new TextDecoder('utf-8').decode(bytes);
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ Base64
            bytesToBase64(bytes) {
                let binary = '';
                for (let i = 0; i < bytes.length; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏–∑ Base64
            base64ToBytes(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes;
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞ –∏–∑ —Å—Ç—Ä–æ–∫–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º SHA-256
            async generateKey(keyString, salt = null) {
                // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–ª—å, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞
                let keyMaterial = keyString;
                if (salt) {
                    keyMaterial += salt;
                }
                
                // –•–µ—à–∏—Ä—É–µ–º –∫–ª—é—á —Å –ø–æ–º–æ—â—å—é SHA-256
                const hash = await this.sha256.hash(keyMaterial);
                this.log(`üîë –•–µ—à –∫–ª—é—á–∞ (SHA-256): ${hash}`, 'info');
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ö–µ—à –≤ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä
                const keyMultivector = this.algebra.multivectorFromHash(hash);
                
                // –õ–æ–≥–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∫–ª—é—á–∞
                let componentsLog = "–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∫–ª—é—á–µ–≤–æ–≥–æ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–∞:\n";
                for (let i = 0; i < keyMultivector.length; i++) {
                    componentsLog += `  e${i}: ${keyMultivector[i].toFixed(6)}\n`;
                }
                this.log(componentsLog, 'info');
                
                return {
                    multivector: keyMultivector,
                    hash: hash
                };
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —á–∏—Å–ª–∞ –≤ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä (—Ç–æ–ª—å–∫–æ —Å–∫–∞–ª—è—Ä–Ω–∞—è —á–∞—Å—Ç—å)
            numberToMultivector(n) {
                const mv = new Array(this.algebra.basisCount).fill(0);
                mv[0] = n / 128 - 1; // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É [-1, 1]
                return mv;
            }

            // –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —á–∏—Å–ª–∞ –∏–∑ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä–∞ (—Å–∫–∞–ª—è—Ä–Ω–∞—è —á–∞—Å—Ç—å)
            multivectorToNumber(mv) {
                // –î–µ–Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∏–∑ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ [-1, 1] –≤ [0, 255]
                const value = Math.round((mv[0] + 1) * 128);
                return Math.max(0, Math.min(255, value));
            }

            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –±–∞–π—Ç–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            encryptByte(byte, keyMultivector) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç –≤ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä
                const byteMV = this.numberToMultivector(byte);
                
                // –í—ã—á–∏—Å–ª—è–µ–º: C = K * P * K‚Åª¬π
                const kInverse = this.algebra.inverse(keyMultivector);
                const kp = this.algebra.multiply(keyMultivector, byteMV);
                const resultMV = this.algebra.multiply(kp, kInverse);
                
                // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                return this.multivectorToNumber(resultMV);
            }

            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –±–∞–π—Ç–∞
            decryptByte(byte, keyMultivector) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç –≤ –º—É–ª—å—Ç–∏–≤–µ–∫—Ç–æ—Ä
                const byteMV = this.numberToMultivector(byte);
                
                // –í—ã—á–∏—Å–ª—è–µ–º: P = K‚Åª¬π * C * K
                const kInverse = this.algebra.inverse(keyMultivector);
                const kInverseC = this.algebra.multiply(kInverse, byteMV);
                const resultMV = this.algebra.multiply(kInverseC, keyMultivector);
                
                // –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                return this.multivectorToNumber(resultMV);
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            async encryptText(text, keyString) {
                this.debugLog = [];
                const debugOutput = document.getElementById('debugOutput');
                if (debugOutput) debugOutput.innerHTML = '';
                
                this.log('üöÄ –ù–∞—á–∞–ª–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞', 'info');
                
                if (keyString.length < 16) {
                    throw new Error('–ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 16 —Å–∏–º–≤–æ–ª–æ–≤');
                }
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–æ–ª—å, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                let salt = null;
                if (document.getElementById('addSalt').checked) {
                    salt = this.generateSalt();
                    this.log(`üßÇ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ —Å–æ–ª—å: ${this.bytesToBase64(salt)}`, 'info');
                }
                
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª—é—á –∏–∑ –ø–∞—Ä–æ–ª—è
                const keyData = await this.generateKey(keyString, salt);
                const keyMultivector = keyData.multivector;
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–µ–∫—Å—Ç –≤ –±–∞–π—Ç—ã
                const textBytes = this.stringToBytes(text);
                this.log(`üìä –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: "${text}" (${textBytes.length} –±–∞–π—Ç)`, 'info');
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–ª—å –∫ –¥–∞–Ω–Ω—ã–º, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
                let dataToEncrypt = textBytes;
                if (salt) {
                    const combined = new Uint8Array(salt.length + textBytes.length);
                    combined.set(salt);
                    combined.set(textBytes, salt.length);
                    dataToEncrypt = combined;
                    this.log(`üì¶ –î–∞–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: —Å–æ–ª—å + —Ç–µ–∫—Å—Ç (${dataToEncrypt.length} –±–∞–π—Ç)`, 'info');
                }
                
                // –®–∏—Ñ—Ä—É–µ–º –∫–∞–∂–¥—ã–π –±–∞–π—Ç
                const encryptedBytes = new Uint8Array(dataToEncrypt.length);
                for (let i = 0; i < dataToEncrypt.length; i++) {
                    encryptedBytes[i] = this.encryptByte(dataToEncrypt[i], keyMultivector);
                    if (i < 5 || i > dataToEncrypt.length - 5) {
                        this.log(`üî¢ –ë–∞–π—Ç ${i}: ${dataToEncrypt[i]} ‚Üí ${encryptedBytes[i]}`, 'info');
                    } else if (i === 5) {
                        this.log(`... (–ø—Ä–æ–ø—É—â–µ–Ω–æ ${dataToEncrypt.length - 10} –±–∞–π—Ç)`, 'info');
                    }
                }
                
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ Base64
                const base64String = this.bytesToBase64(encryptedBytes);
                
                this.log('üéØ –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                
                return {
                    ciphertext: base64String,
                    debug: this.debugLog,
                    original: text,
                    keyHash: keyData.hash
                };
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            async decryptText(ciphertext, keyString) {
                this.debugLog = [];
                const debugOutput = document.getElementById('debugOutput');
                if (debugOutput) debugOutput.innerHTML = '';
                
                this.log('üîì –ù–∞—á–∞–ª–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'info');
                
                try {
                    // –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∏–∑ Base64
                    const encryptedBytes = this.base64ToBytes(ciphertext);
                    this.log(`üìä –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: ${encryptedBytes.length} –±–∞–π—Ç`, 'info');
                    
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–ª—é—á –∏–∑ –ø–∞—Ä–æ–ª—è (–ø–æ–∫–∞ –±–µ–∑ —Å–æ–ª–∏, –æ–Ω–∞ –±—É–¥–µ—Ç –∏–∑–≤–ª–µ—á–µ–Ω–∞ –∏–∑ –¥–∞–Ω–Ω—ã—Ö)
                    const keyData = await this.generateKey(keyString);
                    const keyMultivector = keyData.multivector;
                    
                    // –î–µ—à–∏—Ñ—Ä—É–µ–º –∫–∞–∂–¥—ã–π –±–∞–π—Ç
                    const decryptedBytes = new Uint8Array(encryptedBytes.length);
                    for (let i = 0; i < encryptedBytes.length; i++) {
                        decryptedBytes[i] = this.decryptByte(encryptedBytes[i], keyMultivector);
                        if (i < 5 || i > encryptedBytes.length - 5) {
                            this.log(`üî¢ –ë–∞–π—Ç ${i}: ${encryptedBytes[i]} ‚Üí ${decryptedBytes[i]}`, 'info');
                        } else if (i === 5) {
                            this.log(`... (–ø—Ä–æ–ø—É—â–µ–Ω–æ ${encryptedBytes.length - 10} –±–∞–π—Ç)`, 'info');
                        }
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–æ–ª—å –≤ –¥–∞–Ω–Ω—ã—Ö
                    let textBytes = decryptedBytes;
                    if (document.getElementById('addSalt').checked && decryptedBytes.length >= 16) {
                        // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç - —ç—Ç–æ —Å–æ–ª—å
                        const salt = decryptedBytes.slice(0, 16);
                        textBytes = decryptedBytes.slice(16);
                        this.log(`üßÇ –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Å–æ–ª—å: ${this.bytesToBase64(salt)}`, 'info');
                    }
                    
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ç–µ–∫—Å—Ç
                    const text = this.bytesToString(textBytes);
                    
                    this.log('üéØ –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                    
                    return {
                        plaintext: text,
                        debug: this.debugLog
                    };
                } catch (error) {
                    this.log(`‚ùå –û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–π —Å–æ–ª–∏
            generateSalt() {
                const salt = new Uint8Array(16);
                for (let i = 0; i < salt.length; i++) {
                    salt[i] = Math.floor(Math.random() * 256);
                }
                return salt;
            }
            
            // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏
            async testReversibility() {
                this.log('üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏ –æ–ø–µ—Ä–∞—Ü–∏–π', 'info');
                
                const testValues = [10, 100, 200, 50];
                const testKey = "TestKey1234567890!";
                
                const keyData = await this.generateKey(testKey);
                const keyMultivector = keyData.multivector;
                
                for (const value of testValues) {
                    this.log(`–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è: ${value}`, 'info');
                    
                    const encrypted = this.encryptByte(value, keyMultivector);
                    this.log(`–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: ${encrypted}`, 'info');
                    
                    const decrypted = this.decryptByte(encrypted, keyMultivector);
                    this.log(`–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: ${decrypted}`, 'info');
                    
                    if (value === decrypted) {
                        this.log('‚úì –û–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞', 'success');
                    } else {
                        this.log('‚úó –û—à–∏–±–∫–∞ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏', 'error');
                    }
                }
            }
            
            // –û—Ü–µ–Ω–∫–∞ —ç–Ω—Ç—Ä–æ–ø–∏–∏ –∫–ª—é—á–∞
            calculateEntropy(keyString) {
                // –ü—Ä–æ—Å—Ç–∞—è –æ—Ü–µ–Ω–∫–∞ —ç–Ω—Ç—Ä–æ–ø–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è —Å–∏–º–≤–æ–ª–æ–≤
                const charSet = new Set();
                for (const char of keyString) {
                    charSet.add(char);
                }
                
                // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è –¥–ª—è —Å—Ç—Ä–æ–∫–∏ –¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã
                const maxEntropy = keyString.length * Math.log2(94); // 94 –ø–µ—á–∞—Ç–Ω—ã—Ö ASCII —Å–∏–º–≤–æ–ª–∞
                
                // –§–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —ç–Ω—Ç—Ä–æ–ø–∏—è (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞)
                const actualEntropy = charSet.size * Math.log2(94);
                
                return {
                    bits: Math.min(actualEntropy, maxEntropy),
                    diversity: charSet.size / keyString.length
                };
            }
        }

        const cipher = new EnhancedCliffordCipher();

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ —Å–∏–ª—ã –∫–ª—é—á–∞
        function updateKeyStrength() {
            const keyString = document.getElementById('encryptionKey').value;
            const strengthBar = document.getElementById('keyStrengthBar');
            const strengthText = document.getElementById('keyStrengthText');
            const entropyInfo = document.getElementById('keyEntropy');
            const keyVisualization = document.getElementById('keyVisualization');
            
            if (keyString.length === 0) {
                strengthBar.style.width = '0%';
                strengthText.textContent = '–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å –∫–ª—é—á–∞: –Ω–µ –æ—Ü–µ–Ω–µ–Ω–∞';
                entropyInfo.textContent = '–≠–Ω—Ç—Ä–æ–ø–∏—è: 0 –±–∏—Ç';
                keyVisualization.textContent = '–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª—é—á–∞ –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å –ø–æ—Å–ª–µ –≤–≤–æ–¥–∞...';
                return;
            }
            
            // –û—Ü–µ–Ω–∏–≤–∞–µ–º —ç–Ω—Ç—Ä–æ–ø–∏—é –∫–ª—é—á–∞
            const entropy = cipher.calculateEntropy(keyString);
            
            // –í—ã—á–∏—Å–ª—è–µ–º –æ—Ü–µ–Ω–∫—É –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ (0-100)
            let strength = 0;
            if (keyString.length < 8) {
                strength = Math.min(30, keyString.length * 4);
            } else if (keyString.length < 16) {
                strength = 30 + Math.min(40, (keyString.length - 8) * 5);
            } else {
                strength = 70 + Math.min(30, (keyString.length - 16) * 2);
            }
            
            // –£—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ —Å–∏–º–≤–æ–ª–æ–≤
            strength = Math.min(100, strength * (1 + entropy.diversity) / 2);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            strengthBar.style.width = `${strength}%`;
            
            if (strength < 40) {
                strengthBar.style.background = 'var(--error)';
                strengthText.textContent = '–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å –∫–ª—é—á–∞: —Å–ª–∞–±–∞—è';
            } else if (strength < 70) {
                strengthBar.style.background = 'var(--warning)';
                strengthText.textContent = '–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å –∫–ª—é—á–∞: —Å—Ä–µ–¥–Ω—è—è';
            } else {
                strengthBar.style.background = 'var(--success)';
                strengthText.textContent = '–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å –∫–ª—é—á–∞: —Å–∏–ª—å–Ω–∞—è';
            }
            
            entropyInfo.textContent = `–≠–Ω—Ç—Ä–æ–ø–∏—è: ~${Math.round(entropy.bits)} –±–∏—Ç`;
            
            // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª—é—á–∞ (–ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç —Ö–µ—à–∞)
            if (keyString.length >= 8) {
                cipher.sha256.hash(keyString).then(hash => {
                    keyVisualization.textContent = `–•–µ—à –∫–ª—é—á–∞ (SHA-256): ${hash.substring(0, 32)}...`;
                }).catch(() => {
                    keyVisualization.textContent = '–û—à–∏–±–∫–∞ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ö–µ—à–∞';
                });
            } else {
                keyVisualization.textContent = '–ö–ª—é—á —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏';
            }
        }

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–ª—é—á–∞
        function generateStrongKey() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_-+=[]{}|;:,.<>?';
            let key = '';
            const length = 24; // –î–ª–∏–Ω–∞ –∫–ª—é—á–∞
            
            for (let i = 0; i < length; i++) {
                key += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            
            document.getElementById('encryptionKey').value = key;
            updateKeyStrength();
            
            document.getElementById('validationOutput').textContent = '‚úì –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –Ω–æ–≤—ã–π —Å–ª—É—á–∞–π–Ω—ã–π –∫–ª—é—á';
            document.getElementById('validationOutput').className = 'status success';
        }

        async function processEncryption() {
            try {
                const inputText = document.getElementById('inputText').value;
                const keyString = document.getElementById('encryptionKey').value;
                
                if (!inputText) {
                    alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }
                
                if (!keyString) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }

                const result = await cipher.encryptText(inputText, keyString);

                document.getElementById('resultOutput').textContent = 
                    `–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç (Base64):\n${result.ciphertext}\n\n` +
                    `–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: ${result.original}\n` +
                    `–î–ª–∏–Ω–∞: ${result.ciphertext.length} —Å–∏–º–≤–æ–ª–æ–≤ Base64\n` +
                    `–•–µ—à –∫–ª—é—á–∞: ${result.keyHash.substring(0, 32)}...`;

                document.getElementById('validationOutput').textContent = '‚úì –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('validationOutput').textContent = `‚úó –û—à–∏–±–∫–∞: ${error.message}`;
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        async function processDecryption() {
            try {
                const inputText = document.getElementById('inputText').value;
                const keyString = document.getElementById('encryptionKey').value;
                
                if (!inputText) {
                    alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }
                
                if (!keyString) {
                    alert('–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }

                const result = await cipher.decryptText(inputText, keyString);
                
                document.getElementById('resultOutput').textContent = 
                    `–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:\n${result.plaintext}\n\n` +
                    `–î–ª–∏–Ω–∞: ${result.plaintext.length} —Å–∏–º–≤–æ–ª–æ–≤`;
                
                document.getElementById('validationOutput').textContent = '‚úì –¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('validationOutput').textContent = `‚úó –û—à–∏–±–∫–∞: ${error.message}`;
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        function testReversibility() {
            const debugOutput = document.getElementById('debugOutput');
            if (debugOutput) debugOutput.innerHTML = '';
            
            cipher.testReversibility();
            
            document.getElementById('resultOutput').textContent = 
                '–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏ —Å–º–æ—Ç—Ä–∏ –≤ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –Ω–∏–∂–µ';
            document.getElementById('validationOutput').textContent = '‚úì –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ';
            document.getElementById('validationOutput').className = 'status success';
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('encryptionKey').value = '';
            document.getElementById('resultOutput').textContent = '‚Äî';
            document.getElementById('validationOutput').textContent = '‚Äî';
            document.getElementById('validationOutput').className = 'status';
            document.getElementById('debugOutput').innerHTML = '‚Äî';
            updateKeyStrength();
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.getElementById('encryptionKey').addEventListener('input', updateKeyStrength);
        document.addEventListener('DOMContentLoaded', function() {
            updateKeyStrength();
        });
    </script>
</body>
</html>
