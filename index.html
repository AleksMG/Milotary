<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clifford Cipher - Рабочая версия</title>
    <style>
        :root {
            --ios-bg: #f5f5f7;
            --ios-card: #ffffff;
            --ios-text: #1d1d1f;
            --ios-blue: #007aff;
            --ios-green: #34c759;
            --ios-red: #ff3b30;
            --ios-border: #e5e5ea;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--ios-bg);
            color: var(--ios-text);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--ios-blue);
            color: white;
            border-radius: 16px;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .card {
            background: var(--ios-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--ios-border);
        }
        
        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        textarea, input {
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--ios-border);
            background: var(--ios-card);
            color: var(--ios-text);
            font-family: monospace;
            font-size: 16px;
            resize: vertical;
            margin-bottom: 15px;
        }
        
        .btn-group {
            display: flex;
            gap: 12px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            background: var(--ios-blue);
            color: white;
            flex: 1;
            min-width: 120px;
        }
        
        button:hover {
            opacity: 0.9;
        }
        
        .output {
            background: var(--ios-bg);
            padding: 15px;
            border-radius: 12px;
            margin-top: 15px;
            min-height: 100px;
            font-family: monospace;
            white-space: pre-wrap;
            border: 1px solid var(--ios-border);
            font-size: 14px;
        }
        
        .status {
            padding: 12px;
            border-radius: 12px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
        }
        
        .success {
            background: rgba(52, 199, 89, 0.1);
            border: 1px solid var(--ios-green);
            color: var(--ios-green);
        }
        
        .error {
            background: rgba(255, 59, 48, 0.1);
            border: 1px solid var(--ios-red);
            color: var(--ios-red);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Clifford Cipher</h1>
            <p>Исправленная рабочая версия</p>
        </div>
        
        <div class="card">
            <div class="card-title">Исходный текст</div>
            <textarea id="inputText" rows="4">Тестовое сообщение</textarea>
            
            <div class="card-title">Ключ шифрования</div>
            <input type="text" id="encryptionKey" value="StrongKey123456">
        </div>
        
        <div class="btn-group">
            <button onclick="encryptText()">Зашифровать</button>
            <button onclick="decryptText()">Расшифровать</button>
            <button onclick="testReversibility()">Тест обратимости</button>
        </div>
        
        <div class="card">
            <div class="card-title">Результаты</div>
            <div class="output" id="resultOutput">—</div>
            <div id="validationOutput" class="status">—</div>
        </div>
    </div>

    <script>
        // Правильная реализация с гарантией диапазона значений
        class WorkingCliffordAlgebra {
            constructor() {
                this.dimension = 4;
                this.metric = [1, 1, 1, -1];
                this.basisCount = 16;
                this.multiplicationTable = this.generateMultiplicationTable();
            }
            
            generateMultiplicationTable() {
                const table = new Array(this.basisCount);
                for (let i = 0; i < this.basisCount; i++) {
                    table[i] = new Array(this.basisCount);
                    for (let j = 0; j < this.basisCount; j++) {
                        table[i][j] = this.multiplyBasisElements(i, j);
                    }
                }
                return table;
            }
            
            multiplyBasisElements(a, b) {
                if (a === 0) return { value: b, sign: 1 };
                if (b === 0) return { value: a, sign: 1 };
                
                const aVectors = this.getBasisVectors(a);
                const bVectors = this.getBasisVectors(b);
                
                let resultVectors = [...aVectors];
                let sign = 1;
                
                for (const bVec of bVectors) {
                    let insertPos = resultVectors.length;
                    
                    for (let i = 0; i < resultVectors.length; i++) {
                        if (resultVectors[i] === bVec) {
                            sign *= this.metric[bVec];
                            resultVectors.splice(i, 1);
                            insertPos = -1;
                            break;
                        } else if (resultVectors[i] > bVec) {
                            insertPos = i;
                            break;
                        }
                    }
                    
                    if (insertPos >= 0) {
                        sign *= Math.pow(-1, resultVectors.length - insertPos);
                        resultVectors.splice(insertPos, 0, bVec);
                    }
                }
                
                let resultValue = 0;
                for (const vec of resultVectors) {
                    resultValue |= (1 << vec);
                }
                
                return { value: resultValue, sign: sign };
            }
            
            getBasisVectors(x) {
                const vectors = [];
                for (let i = 0; i < this.dimension; i++) {
                    if (x & (1 << i)) {
                        vectors.push(i);
                    }
                }
                return vectors.sort((a, b) => a - b);
            }
            
            multiply(a, b) {
                const result = new Array(this.basisCount).fill(0);
                
                for (let i = 0; i < this.basisCount; i++) {
                    if (Math.abs(a[i]) < 1e-10) continue;
                    
                    for (let j = 0; j < this.basisCount; j++) {
                        if (Math.abs(b[j]) < 1e-10) continue;
                        
                        const product = this.multiplicationTable[i][j];
                        const coefficient = a[i] * b[j] * product.sign;
                        result[product.value] = (result[product.value] || 0) + coefficient;
                    }
                }
                
                return result;
            }
            
            inverse(mv) {
                const reversed = this.reverse(mv);
                const norm = this.multiply(mv, reversed);
                
                if (Math.abs(norm[0]) < 1e-10) {
                    throw new Error("Невозможно обратить мультивектор");
                }
                
                const result = new Array(this.basisCount).fill(0);
                for (let i = 0; i < this.basisCount; i++) {
                    result[i] = reversed[i] / norm[0];
                }
                
                return result;
            }
            
            reverse(mv) {
                const result = [...mv];
                for (let i = 1; i < this.basisCount; i++) {
                    const vectors = this.getBasisVectors(i);
                    if (vectors.length % 2 === 1) {
                        result[i] = -result[i];
                    }
                }
                return result;
            }
            
            // ФИКС: Гарантируем, что значения остаются в допустимом диапазоне
            bytesToMultivector(bytes) {
                const mv = new Array(this.basisCount).fill(0);
                for (let i = 0; i < this.basisCount; i++) {
                    // Масштабируем в диапазон [-0.5, 0.5] для избежания переполнения
                    mv[i] = (bytes[i] / 255) - 0.5;
                }
                return mv;
            }
            
            multivectorToBytes(mv) {
                const bytes = new Uint8Array(this.basisCount);
                for (let i = 0; i < this.basisCount; i++) {
                    // Обратное масштабирование с проверкой границ
                    let value = Math.round((mv[i] + 0.5) * 255);
                    value = Math.max(0, Math.min(255, value));
                    bytes[i] = value;
                }
                return bytes;
            }
        }

        class WorkingCliffordCipher {
            constructor() {
                this.algebra = new WorkingCliffordAlgebra();
            }
            
            async encryptText(text, keyString) {
                try {
                    const keyBytes = new TextEncoder().encode(keyString);
                    const textBytes = new TextEncoder().encode(text);
                    
                    // Дополняем ключ до 16 байт
                    const paddedKey = this.padTo16Bytes(keyBytes);
                    const keyMultivector = this.algebra.bytesToMultivector(paddedKey);
                    
                    const resultBytes = new Uint8Array(textBytes.length);
                    
                    for (let i = 0; i < textBytes.length; i++) {
                        // Создаем мультивектор только из одного байта (остальные 0)
                        const byteArray = new Uint8Array(16);
                        byteArray[0] = textBytes[i];
                        const byteMV = this.algebra.bytesToMultivector(byteArray);
                        
                        const kInverse = this.algebra.inverse(keyMultivector);
                        
                        // K * P * K⁻¹
                        const kp = this.algebra.multiply(keyMultivector, byteMV);
                        const encryptedMV = this.algebra.multiply(kp, kInverse);
                        
                        const encryptedBytes = this.algebra.multivectorToBytes(encryptedMV);
                        resultBytes[i] = encryptedBytes[0]; // Берем только первый байт
                    }
                    
                    return Array.from(resultBytes);
                } catch (error) {
                    throw new Error(`Ошибка шифрования: ${error.message}`);
                }
            }
            
            async decryptText(encryptedBytes, keyString) {
                try {
                    const keyBytes = new TextEncoder().encode(keyString);
                    const paddedKey = this.padTo16Bytes(keyBytes);
                    const keyMultivector = this.algebra.bytesToMultivector(paddedKey);
                    
                    const resultBytes = new Uint8Array(encryptedBytes.length);
                    
                    for (let i = 0; i < encryptedBytes.length; i++) {
                        // Создаем мультивектор из зашифрованного байта
                        const byteArray = new Uint8Array(16);
                        byteArray[0] = encryptedBytes[i];
                        const byteMV = this.algebra.bytesToMultivector(byteArray);
                        
                        const kInverse = this.algebra.inverse(keyMultivector);
                        
                        // K⁻¹ * C * K
                        const kInverseC = this.algebra.multiply(kInverse, byteMV);
                        const decryptedMV = this.algebra.multiply(kInverseC, keyMultivector);
                        
                        const decryptedBytes = this.algebra.multivectorToBytes(decryptedMV);
                        resultBytes[i] = decryptedBytes[0];
                    }
                    
                    return new TextDecoder().decode(resultBytes);
                } catch (error) {
                    throw new Error(`Ошибка дешифрования: ${error.message}`);
                }
            }
            
            padTo16Bytes(bytes) {
                const result = new Uint8Array(16);
                for (let i = 0; i < 16; i++) {
                    result[i] = bytes[i % bytes.length];
                }
                return result;
            }
            
            async testReversibility() {
                const testText = "Test123";
                const testKey = "Key123";
                
                try {
                    const encrypted = await this.encryptText(testText, testKey);
                    const decrypted = await this.decryptText(encrypted, testKey);
                    
                    return {
                        success: decrypted === testText,
                        original: testText,
                        decrypted: decrypted,
                        encrypted: encrypted
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
        }

        const cipher = new WorkingCliffordCipher();

        async function encryptText() {
            try {
                const text = document.getElementById('inputText').value;
                const key = document.getElementById('encryptionKey').value;
                
                if (!text || !key) {
                    throw new Error("Введите текст и ключ");
                }
                
                const encrypted = await cipher.encryptText(text, key);
                document.getElementById('resultOutput').textContent = 
                    `Зашифрованные байты:\n[${encrypted.join(', ')}]`;
                
                document.getElementById('validationOutput').textContent = '✓ Шифрование успешно';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('resultOutput').textContent = error.message;
                document.getElementById('validationOutput').textContent = '✗ Ошибка шифрования';
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        async function decryptText() {
            try {
                const text = document.getElementById('inputText').value;
                const key = document.getElementById('encryptionKey').value;
                
                if (!text || !key) {
                    throw new Error("Введите данные и ключ");
                }
                
                // Парсим байты из текста
                const byteMatch = text.match(/\[([^\]]+)\]/);
                let bytes;
                
                if (byteMatch) {
                    bytes = byteMatch[1].split(',').map(b => parseInt(b.trim()));
                    const decrypted = await cipher.decryptText(bytes, key);
                    document.getElementById('resultOutput').textContent = 
                        `Расшифрованный текст: ${decrypted}`;
                } else {
                    // Если это не байты, шифруем и сразу дешифруем
                    const encrypted = await cipher.encryptText(text, key);
                    const decrypted = await cipher.decryptText(encrypted, key);
                    document.getElementById('resultOutput').textContent = 
                        `Зашифровано: [${encrypted.join(', ')}]\nРасшифровано: ${decrypted}`;
                }
                
                document.getElementById('validationOutput').textContent = '✓ Дешифрование успешно';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('resultOutput').textContent = error.message;
                document.getElementById('validationOutput').textContent = '✗ Ошибка дешифрования';
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        async function testReversibility() {
            try {
                const result = await cipher.testReversibility();
                
                if (result.success) {
                    document.getElementById('resultOutput').textContent = 
                        `ТЕСТ ПРОЙДЕН!\nОригинал: "${result.original}"\nЗашифровано: [${result.encrypted.join(', ')}]\nРасшифровано: "${result.decrypted}"`;
                    document.getElementById('validationOutput').textContent = '✓ Тест обратимости пройден';
                    document.getElementById('validationOutput').className = 'status success';
                } else {
                    document.getElementById('resultOutput').textContent = 
                        `Ошибка теста: ${result.error}`;
                    document.getElementById('validationOutput').textContent = '✗ Тест не пройден';
                    document.getElementById('validationOutput').className = 'status error';
                }
            } catch (error) {
                document.getElementById('resultOutput').textContent = error.message;
                document.getElementById('validationOutput').textContent = '✗ Ошибка теста';
                document.getElementById('validationOutput').className = 'status error';
            }
        }
    </script>
</body>
</html>
