<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–£–ª—É—á—à–µ–Ω–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #0f0f23;
            color: #00ff00;
            line-height: 1.6;
        }
        .container {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #00ff00;
            border-radius: 5px;
            background: rgba(0, 255, 0, 0.05);
        }
        h1, h2 {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00ff00;
        }
        textarea {
            width: 100%;
            height: 100px;
            background: #1c1c1c;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px;
            font-family: monospace;
            border-radius: 4px;
            resize: vertical;
        }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 12px 24px;
            margin: 10px 5px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }
        button:hover {
            background: #00cc00;
            box-shadow: 0 0 10px #00ff00;
        }
        .output {
            background: #1c1c1c;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #00ff00;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
        }
        .debug {
            background: #2a2a2a;
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid #ff9900;
            border-radius: 3px;
        }
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .warning { color: #ff9900; }
        .info { color: #00ccff; }
        .flex-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .status {
            padding: 10px;
            text-align: center;
            font-weight: bold;
            border-radius: 4px;
            margin: 10px 0;
        }
        .valid {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
        }
        .invalid {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
        }
    </style>
</head>
<body>
    <h1>üîê –£–ª—É—á—à–µ–Ω–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞</h1>

    <div class="container">
        <h2>üìù –ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</h2>
        <textarea id="inputText">–ü—Ä–∏–≤–µ—Ç –º–∏—Ä! –¢–µ—Å—Ç–∏—Ä—É–µ–º —É–ª—É—á—à–µ–Ω–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ.</textarea>
        <div class="flex-row">
            <button onclick="processEncryption()">üîÑ –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="processDecryption()">‚Ü©Ô∏è –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <button onclick="clearAll()">‚ùå –û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
    </div>

    <div class="container">
        <h2>üîß –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∏—Å—Ç–µ–º—ã</h2>
        <div class="debug">
            <strong>–ê–ª–≥–µ–±—Ä–∞ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞ Cl(3,1; ‚Ñ§‚ÇÇ‚ÇÖ‚ÇÅ)</strong><br>
            ‚Ä¢ –ü—Ä–æ—Å—Ç–æ–µ —á–∏—Å–ª–æ: 251<br>
            ‚Ä¢ –†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å: 4 (3+1)<br>
            ‚Ä¢ –£—Ä–æ–≤–Ω–µ–π —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: 3<br>
            ‚Ä¢ –ë–∞–∑–∏—Å: {1, e‚ÇÅ, e‚ÇÇ, e‚ÇÉ, e‚ÇÑ, e‚ÇÅe‚ÇÇ, e‚ÇÅe‚ÇÉ, ..., e‚ÇÅe‚ÇÇe‚ÇÉe‚ÇÑ}<br>
            ‚Ä¢ –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ: 1:1 (–±–∞–π—Ç ‚Üí –±–∞–π—Ç)
        </div>
    </div>

    <div class="container">
        <h2>üßÆ –ü—Ä–æ—Ü–µ—Å—Å —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è/–¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
        <div class="output" id="processOutput">–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...</div>
    </div>

    <div class="container">
        <h2>üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
        <div class="output" id="resultOutput">‚Äî</div>
        <div id="validationOutput" class="status">‚Äî</div>
    </div>

    <div class="container">
        <h2>üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞</h2>
        <div id="statsOutput" class="output">‚Äî</div>
    </div>

    <script>
        class ImprovedCliffordCipher {
            constructor() {
                this.prime = 251n;
                this.dimension = 4;
                this.levels = 3;
                this.debugLog = [];
                
                // –ë–∞–∑–∏—Å–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
                this.basis = [0n]; // –°–∫–∞–ª—è—Ä
                for (let i = 0; i < this.dimension; i++) {
                    this.basis.push(1n << BigInt(i));
                }
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                this.debugLog.push({message: `[${timestamp}] ${message}`, type, time: Date.now()});
                return message;
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Å—Ç–∏—á–µ—Å–∫–æ–≥–æ –∫–ª—é—á–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            generateKeyFromInput(input) {
                let hash = 5381n;
                const encoder = new TextEncoder();
                const data = encoder.encode(input);
                
                for (let i = 0; i < data.length; i++) {
                    hash = (hash * 33n + BigInt(data[i])) % this.prime;
                }
                
                this.log(`üîë –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–ª—é—á –∏–∑ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: ${hash}`);
                return hash;
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∞–ª–≥–µ–±—Ä—ã –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            createAlgebraElements(key) {
                const elements = [];
                for (let i = 0; i < this.levels; i++) {
                    const element = new Map();
                    
                    // –°–∫–∞–ª—è—Ä–Ω–∞—è —á–∞—Å—Ç—å
                    element.set(0n, (key + BigInt(i * 19)) % this.prime);
                    
                    // –í–µ–∫—Ç–æ—Ä–Ω—ã–µ —á–∞—Å—Ç–∏
                    for (let j = 0; j < this.dimension; j++) {
                        const basisKey = 1n << BigInt(j);
                        const value = (key + BigInt(i * j * 11 + 7)) % this.prime;
                        if (value !== 0n) {
                            element.set(basisKey, value);
                        }
                    }
                    
                    // –ë–∏–≤–µ–∫—Ç–æ—Ä—ã
                    for (let j = 0; j < this.dimension; j++) {
                        for (let k = j + 1; k < this.dimension; k++) {
                            const basisKey = (1n << BigInt(j)) | (1n << BigInt(k));
                            const value = (key + BigInt(i * j * k * 3 + 13)) % this.prime;
                            if (value !== 0n && Math.random() > 0.5) {
                                element.set(basisKey, value);
                            }
                        }
                    }
                    
                    elements.push(element);
                    this.log(`üìê –°–æ–∑–¥–∞–Ω —ç–ª–µ–º–µ–Ω—Ç —É—Ä–æ–≤–Ω—è ${i+1}: ${this.elementToString(element)}`);
                }
                return elements;
            }

            // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–ª—è –≤—ã–≤–æ–¥–∞
            elementToString(element) {
                let result = [];
                for (const [key, value] of element) {
                    if (key === 0n) {
                        result.push(`${value}`);
                    } else {
                        let basis = [];
                        for (let i = 0; i < this.dimension; i++) {
                            if (key & (1n << BigInt(i))) {
                                basis.push(`e${i+1}`);
                            }
                        }
                        result.push(`${value}${basis.join('')}`);
                    }
                }
                return result.join(' + ');
            }

            // –ü–æ–¥—Å—á–µ—Ç –∑–Ω–∞–∫–∞ –¥–ª—è —É–º–Ω–æ–∂–µ–Ω–∏—è –≤ –∞–ª–≥–µ–±—Ä–µ –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            countSign(a, b) {
                // –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫ –¥–ª—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º–µ
                let sign = 1n;
                let aBits = a;
                let bBits = b;
                
                // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –±–∏—Ç–∞ –≤ a
                for (let i = 0; i < this.dimension; i++) {
                    if (aBits & (1n << BigInt(i))) {
                        // –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –±–∏—Ç–æ–≤ –≤ b —Å –∏–Ω–¥–µ–∫—Å–æ–º –º–µ–Ω—å—à–µ i
                        for (let j = 0; j < i; j++) {
                            if (bBits & (1n << BigInt(j))) {
                                sign = -sign;
                            }
                        }
                    }
                }
                
                return sign;
            }

            // –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —É–º–Ω–æ–∂–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∞–ª–≥–µ–±—Ä—ã –ö–ª–∏—Ñ—Ñ–æ—Ä–¥–∞
            multiply(a, b) {
                const result = new Map();
                
                for (const [aKey, aVal] of a) {
                    for (const [bKey, bVal] of b) {
                        if (aVal === 0n || bVal === 0n) continue;
                        
                        const sign = this.countSign(aKey, bKey);
                        const productKey = aKey ^ bKey;
                        let productVal = (aVal * bVal * sign) % this.prime;
                        
                        if (productVal < 0n) {
                            productVal += this.prime;
                        }
                        
                        if (productVal !== 0n) {
                            const current = result.get(productKey) || 0n;
                            const newVal = (current + productVal) % this.prime;
                            result.set(productKey, newVal);
                        }
                    }
                }
                
                // –£–¥–∞–ª—è–µ–º –Ω—É–ª–µ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
                for (const [key, value] of result) {
                    if (value === 0n) {
                        result.delete(key);
                    }
                }
                
                this.log(`‚úñÔ∏è –£–º–Ω–æ–∂–µ–Ω–∏–µ: ${this.elementToString(a)} √ó ${this.elementToString(b)} = ${this.elementToString(result)}`);
                return result;
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–∞ –≤ —ç–ª–µ–º–µ–Ω—Ç –∞–ª–≥–µ–±—Ä—ã
            byteToAlgebra(byte) {
                const element = new Map();
                const byteVal = BigInt(byte);
                
                // –°–∫–∞–ª—è—Ä–Ω–∞—è —á–∞—Å—Ç—å
                element.set(0n, byteVal % this.prime);
                
                // –í–µ–∫—Ç–æ—Ä–Ω—ã–µ —á–∞—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–∏—Ç–æ–≤ –±–∞–π—Ç–∞
                for (let i = 0; i < this.dimension; i++) {
                    const bitValue = (byteVal >> BigInt(i)) & 1n;
                    if (bitValue !== 0n) {
                        element.set(1n << BigInt(i), 1n);
                    }
                }
                
                this.log(`‚û°Ô∏è –ë–∞–π—Ç ${byte} ‚Üí —ç–ª–µ–º–µ–Ω—Ç: ${this.elementToString(element)}`);
                return element;
            }

            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–∞ –∞–ª–≥–µ–±—Ä—ã –≤ –±–∞–π—Ç
            algebraToByte(element) {
                let byte = 0;
                const scalar = element.get(0n) || 0n;
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–∞–π—Ç –∏–∑ —Å–∫–∞–ª—è—Ä–Ω–æ–π —á–∞—Å—Ç–∏ –∏ –≤–µ–∫—Ç–æ—Ä–Ω—ã—Ö —á–∞—Å—Ç–µ–π
                byte = Number(scalar % 256n);
                
                // –£—á–∏—Ç—ã–≤–∞–µ–º –≤–µ–∫—Ç–æ—Ä–Ω—ã–µ —á–∞—Å—Ç–∏ (–¥–æ–±–∞–≤–ª—è–µ–º –∏—Ö –≤–ª–∏—è–Ω–∏–µ)
                for (let i = 0; i < this.dimension; i++) {
                    const basisKey = 1n << BigInt(i);
                    if (element.has(basisKey)) {
                        const value = element.get(basisKey);
                        byte = (byte + Number(value)) % 256;
                    }
                }
                
                this.log(`‚¨ÖÔ∏è –≠–ª–µ–º–µ–Ω—Ç ${this.elementToString(element)} ‚Üí –±–∞–π—Ç ${byte}`);
                return byte;
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            encryptText(text) {
                this.debugLog = [];
                this.log('üöÄ –ù–∞—á–∞–ª–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'success');
                
                const key = this.generateKeyFromInput(text);
                const elements = this.createAlgebraElements(key);
                const textBytes = new TextEncoder().encode(text);
                const resultBytes = new Uint8Array(textBytes.length);
                
                this.log(`üìä –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: "${text}" (${textBytes.length} –±–∞–π—Ç)`);

                for (let i = 0; i < textBytes.length; i++) {
                    this.log(`\nüî¢ –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞–π—Ç–∞ ${i+1}/${textBytes.length}: ${textBytes[i]}`, 'warning');
                    
                    let currentElement = this.byteToAlgebra(textBytes[i]);
                    
                    // –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
                    for (let level = 0; level < this.levels; level++) {
                        currentElement = this.multiply(elements[level], currentElement);
                        currentElement = this.multiply(currentElement, elements[level]);
                    }
                    
                    resultBytes[i] = this.algebraToByte(currentElement);
                    this.log(`‚úÖ –ë–∞–π—Ç ${textBytes[i]} ‚Üí ${resultBytes[i]}`);
                }

                this.log('\nüéØ –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                return {
                    ciphertext: resultBytes,
                    debug: this.debugLog,
                    original: textBytes
                };
            }

            // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            decryptText(ciphertext, originalText) {
                this.debugLog = [];
                this.log('üîì –ù–∞—á–∞–ª–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'success');
                
                const key = this.generateKeyFromInput(originalText);
                const elements = this.createAlgebraElements(key);
                const resultBytes = new Uint8Array(ciphertext.length);
                
                this.log(`üìä –®–∏—Ñ—Ä—Ç–µ–∫—Å—Ç: ${ciphertext.length} –±–∞–π—Ç`);

                // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—Ä–∞—Ç–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
                const inverseElements = [];
                for (let level = 0; level < this.levels; level++) {
                    // –î–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç—ã –æ–±—Ä–∞—Ç–∏–º—ã
                    inverseElements.push(elements[level]);
                }

                for (let i = 0; i < ciphertext.length; i++) {
                    this.log(`\nüî¢ –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞–π—Ç–∞ ${i+1}/${ciphertext.length}: ${ciphertext[i]}`, 'warning');
                    
                    let currentElement = this.byteToAlgebra(ciphertext[i]);
                    
                    // –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ (–≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ)
                    for (let level = this.levels - 1; level >= 0; level--) {
                        currentElement = this.multiply(inverseElements[level], currentElement);
                        currentElement = this.multiply(currentElement, inverseElements[level]);
                    }
                    
                    resultBytes[i] = this.algebraToByte(currentElement);
                    this.log(`‚úÖ –ë–∞–π—Ç ${ciphertext[i]} ‚Üí ${resultBytes[i]}`);
                }

                this.log('\nüéØ –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ', 'success');
                return {
                    plaintext: new TextDecoder().decode(resultBytes),
                    debug: this.debugLog,
                    result: resultBytes
                };
            }
        }

        const cipher = new ImprovedCliffordCipher();
        let lastResult = null;

        function processEncryption() {
            const inputText = document.getElementById('inputText').value;
            if (!inputText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è');
                return;
            }

            const result = cipher.encryptText(inputText);
            lastResult = result;

            // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞
            const processOutput = result.debug.map(item => 
                `<span class="${item.type}">${item.message}</span>`
            ).join('\n');
            
            document.getElementById('processOutput').innerHTML = processOutput;
            
            // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            const hexCipher = Array.from(result.ciphertext).map(b => 
                b.toString(16).padStart(2, '0')).join(' ');
            const originalHex = Array.from(result.original).map(b => 
                b.toString(16).padStart(2, '0')).join(' ');
            
            document.getElementById('resultOutput').innerHTML = 
                `üì¶ –®–∏—Ñ—Ä—Ç–µ–∫—Å—Ç: ${hexCipher}\n\n` +
                `üìÑ –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç: ${originalHex}\n` +
                `üî¢ –†–∞–∑–º–µ—Ä: ${result.ciphertext.length} –±–∞–π—Ç`;

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏
            validateEncryption(result, inputText);
            updateStatistics(result);
        }

        function processDecryption() {
            if (!lastResult) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞—à–∏—Ñ—Ä—É–π—Ç–µ —Ç–µ–∫—Å—Ç');
                return;
            }

            const inputText = document.getElementById('inputText').value;
            const result = cipher.decryptText(lastResult.ciphertext, inputText);
            
            document.getElementById('processOutput').innerHTML = 
                result.debug.map(item => `<span class="${item.type}">${item.message}</span>`).join('\n');
            
            const isMatch = result.plaintext === inputText;
            document.getElementById('resultOutput').innerHTML = 
                `üìÑ –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç: "${result.plaintext}"\n\n` +
                `‚úÖ –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Å –∏—Å—Ö–æ–¥–Ω—ã–º: ${isMatch ? '–î–ê' : '–ù–ï–¢'}`;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
            const validationOutput = document.getElementById('validationOutput');
            validationOutput.textContent = isMatch ? 
                '‚úì –¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω' : '‚úó –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏';
            validationOutput.className = isMatch ? 'status valid' : 'status invalid';
        }

        function validateEncryption(result, originalText) {
            const originalBytes = new TextEncoder().encode(originalText);
            let isValid = true;
            let message = '';
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
            const hasOverflow = Array.from(result.ciphertext).some(b => b >= 251);
            if (hasOverflow) {
                isValid = false;
                message += '‚Ä¢ –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ\n';
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏
            const uniqueBytes = new Set(result.ciphertext).size;
            const uniquenessRatio = uniqueBytes / result.ciphertext.length;
            
            if (uniquenessRatio < 0.5 && result.ciphertext.length > 10) {
                isValid = false;
                message += `‚Ä¢ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –±–∞–π—Ç–æ–≤ (—É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å: ${(uniquenessRatio*100).toFixed(1)}%)\n`;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
            const avg = result.ciphertext.reduce((a, b) => a + b, 0) / result.ciphertext.length;
            if (avg < 50 || avg > 200) {
                message += `‚Ä¢ –ù–µ—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ (—Å—Ä–µ–¥–Ω–µ–µ: ${avg.toFixed(2)})\n`;
            }
            
            const validationOutput = document.getElementById('validationOutput');
            if (isValid) {
                validationOutput.textContent = '‚úì –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ';
                validationOutput.className = 'status valid';
            } else {
                validationOutput.textContent = '‚úó –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã:\n' + message;
                validationOutput.className = 'status invalid';
            }
        }

        function updateStatistics(result) {
            const uniqueBytes = new Set(result.ciphertext).size;
            const uniquenessRatio = (uniqueBytes / result.ciphertext.length * 100).toFixed(1);
            const avg = result.ciphertext.reduce((a, b) => a + b, 0) / result.ciphertext.length;
            
            const stats = `üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n` +
                `‚Ä¢ –í—Å–µ–≥–æ –æ–ø–µ—Ä–∞—Ü–∏–π: ${result.debug.length}\n` +
                `‚Ä¢ –£—Ä–æ–≤–Ω–µ–π —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ${cipher.levels}\n` +
                `‚Ä¢ –†–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –∞–ª–≥–µ–±—Ä—ã: ${cipher.dimension}\n` +
                `‚Ä¢ –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –±–∞–π—Ç–æ–≤: ${uniquenessRatio}%\n` +
                `‚Ä¢ –°—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤: ${avg.toFixed(2)}`;
            
            document.getElementById('statsOutput').textContent = stats;
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('processOutput').innerHTML = '–û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...';
            document.getElementById('resultOutput').innerHTML = '‚Äî';
            document.getElementById('statsOutput').textContent = '‚Äî';
            document.getElementById('validationOutput').textContent = '‚Äî';
            document.getElementById('validationOutput').className = 'status';
            lastResult = null;
        }
    </script>
</body>
</html>
