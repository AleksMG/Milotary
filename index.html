<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Шифрование методом алгебры Клиффорда</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #0d1117;
            color: #c9d1d9;
            line-height: 1.6;
        }
        h1 {
            color: #58a6ff;
            text-align: center;
            border-bottom: 2px solid #30363d;
            padding-bottom: 10px;
        }
        .container {
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }
        .input-group {
            margin: 15px 0;
        }
        textarea, input {
            width: 100%;
            background-color: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            resize: vertical;
        }
        button {
            background-color: #238636;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2ea043;
        }
        .output {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .stat-item {
            background-color: #21262d;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #58a6ff;
        }
        .math {
            background-color: #1c2128;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>Шифрование методом алгебры Клиффорда</h1>

    <div class="container">
        <h2>Параметры шифрования</h2>
        <div class="input-group">
            <label for="password">Пароль:</label>
            <input type="password" id="password" placeholder="Введите пароль" value="secret">
        </div>
        <div class="input-group">
            <label for="salt">Соль (hex):</label>
            <input type="text" id="salt" placeholder="Соль для PBKDF2" value="a1b2c3d4">
        </div>
        <div class="input-group">
            <label for="iterations">Итерации PBKDF2:</label>
            <input type="number" id="iterations" value="100000" min="10000" max="1000000">
        </div>
    </div>

    <div class="container">
        <h2>Исходный текст</h2>
        <div class="input-group">
            <textarea id="plaintext" rows="4" placeholder="Введите текст для шифрования">Привет мир! Тестируем шифрование методом Клиффорда.</textarea>
        </div>
        <button onclick="encryptText()">Зашифровать текст</button>
        <div class="output" id="encryptedOutput">Ожидание шифрования...</div>
        
        <div class="stats">
            <div class="stat-item">
                <div>Исходный размер</div>
                <div id="originalSize" class="stat-value">-</div>
                <div>байт</div>
            </div>
            <div class="stat-item">
                <div>Размер шифртекста</div>
                <div id="encryptedSize" class="stat-value">-</div>
                <div>байт</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Дешифрование</h2>
        <button onclick="decryptText()">Дешифровать текст</button>
        <div class="output" id="decryptedOutput">Ожидание дешифрования...</div>
        
        <div class="stats">
            <div class="stat-item">
                <div>Время шифрования</div>
                <div id="encryptTime" class="stat-value">-</div>
                <div>мс</div>
            </div>
            <div class="stat-item">
                <div>Время дешифрования</div>
                <div id="decryptTime" class="stat-value">-</div>
                <div>мс</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Математическая основа</h2>
        <div class="math">
            Алгебра Клиффорда Cl(8, ℤₚ) где p = 251 (простое)<br>
            Шифрование: c = u * m * u⁻¹ (многоуровневое)<br>
            Дешифрование: m = u⁻¹ * c * u<br>
            Ключи генерируются через PBKDF2-SHA256
        </div>
    </div>

    <script>
        class CliffordAlgebraCipher {
            constructor() {
                this.prime = 251n; // Простое число для модульной арифметики
                this.dimension = 8; // Размерность алгебры
                this.levels = 3;   // Количество уровней шифрования
                this.keyLength = 32; // Длина ключа PBKDF2
            }

            // Генерация ключей с PBKDF2
            async generateKeys(password, salt, iterations) {
                const encoder = new TextEncoder();
                
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    'PBKDF2',
                    false,
                    ['deriveBits']
                );
                
                const derivedKey = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: this.hexToBytes(salt),
                        iterations: iterations,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    this.keyLength * 8
                );
                
                return new Uint8Array(derivedKey);
            }

            hexToBytes(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < bytes.length; i++) {
                    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
                }
                return bytes;
            }

            // Создание ключевых элементов для алгебры Клиффорда
            createCliffordKeys(keyMaterial) {
                const keys = [];
                
                for (let level = 0; level < this.levels; level++) {
                    const key = new Map();
                    const offset = level * 4 % keyMaterial.length;
                    
                    // Базовые элементы алгебры
                    key.set(0, BigInt(keyMaterial[offset] + 1) % this.prime); // Скаляр
                    
                    // Векторные элементы e1-e8
                    for (let i = 0; i < 8; i++) {
                        const idx = (offset + i + 1) % keyMaterial.length;
                        key.set(1 << i, BigInt(keyMaterial[idx] + 1) % this.prime);
                    }
                    
                    keys.push(key);
                }
                
                return keys;
            }

            // Преобразование байта в элемент алгебры Клиффорда
            byteToCliffordElement(byte) {
                const element = new Map();
                
                // Используем биты байта для создания элемента
                for (let i = 0; i < 8; i++) {
                    if (byte & (1 << i)) {
                        element.set(1 << i, 1n);
                    }
                }
                
                // Добавляем скалярную часть
                element.set(0, BigInt(byte % Number(this.prime)) + 1n);
                
                return element;
            }

            // Преобразование элемента Клиффорда обратно в байт
            cliffordElementToByte(element) {
                let result = 0;
                
                // Восстанавливаем биты из векторных частей
                for (let i = 0; i < 8; i++) {
                    if (element.has(1 << i) && element.get(1 << i) !== 0n) {
                        result |= (1 << i);
                    }
                }
                
                return result;
            }

            // Умножение в алгебре Клиффорда
            multiply(a, b) {
                const result = new Map();
                
                for (const [aKey, aVal] of a) {
                    for (const [bKey, bVal] of b) {
                        if (aVal === 0n || bVal === 0n) continue;
                        
                        const productKey = aKey ^ bKey;
                        let productVal = (aVal * bVal) % this.prime;
                        
                        // Учет антикоммутативности
                        const sign = this.calculateCliffordSign(aKey, bKey);
                        productVal = (productVal * sign) % this.prime;
                        
                        if (productVal < 0n) productVal += this.prime;
                        
                        const current = result.get(productKey) || 0n;
                        result.set(productKey, (current + productVal) % this.prime);
                    }
                }
                
                return result;
            }

            // Вычисление знака в алгебре Клиффорда
            calculateCliffordSign(a, b) {
                if (a === 0 || b === 0) return 1n;
                
                let sign = 1n;
                let aTemp = a;
                let bTemp = b;
                
                // Подсчет числа перестановок
                while (aTemp && bTemp) {
                    if (aTemp & 1) {
                        const higherBits = bTemp >> 1;
                        if (higherBits & 1) {
                            sign = -sign;
                        }
                    }
                    aTemp >>= 1;
                    bTemp >>= 1;
                }
                
                return sign;
            }

            // Нахождение обратного элемента
            findInverse(element) {
                const inverse = new Map();
                for (const [key, value] of element) {
                    if (value !== 0n) {
                        // Находим обратное по модулю
                        let inv = 1n;
                        let exp = this.prime - 2n;
                        let base = value;
                        
                        while (exp > 0) {
                            if (exp % 2n === 1n) {
                                inv = (inv * base) % this.prime;
                            }
                            base = (base * base) % this.prime;
                            exp >>= 1n;
                        }
                        
                        inverse.set(key, inv);
                    }
                }
                return inverse;
            }

            // Шифрование текста методом Клиффорда
            async encryptText(text, password, salt, iterations) {
                const startTime = performance.now();
                const textBytes = new TextEncoder().encode(text);
                const encryptedBytes = new Uint8Array(textBytes.length);
                
                // Генерация ключей
                const keyMaterial = await this.generateKeys(password, salt, iterations);
                const keys = this.createCliffordKeys(keyMaterial);
                const inverses = keys.map(key => this.findInverse(key));
                
                for (let i = 0; i < textBytes.length; i++) {
                    let element = this.byteToCliffordElement(textBytes[i]);
                    
                    // Многоуровневое шифрование: c = u3 * u2 * u1 * m * u1⁻¹ * u2⁻¹ * u3⁻¹
                    for (let level = 0; level < this.levels; level++) {
                        element = this.multiply(keys[level], this.multiply(element, inverses[level]));
                    }
                    
                    encryptedBytes[i] = this.cliffordElementToByte(element);
                }
                
                const endTime = performance.now();
                
                return {
                    ciphertext: encryptedBytes,
                    performance: {
                        time: endTime - startTime,
                        originalSize: textBytes.length,
                        encryptedSize: encryptedBytes.length
                    }
                };
            }

            // Дешифрование текста
            async decryptText(ciphertext, password, salt, iterations) {
                const startTime = performance.now();
                const decryptedBytes = new Uint8Array(ciphertext.length);
                
                // Генерация ключей (таких же как при шифровании)
                const keyMaterial = await this.generateKeys(password, salt, iterations);
                const keys = this.createCliffordKeys(keyMaterial);
                const inverses = keys.map(key => this.findInverse(key));
                
                for (let i = 0; i < ciphertext.length; i++) {
                    let element = this.byteToCliffordElement(ciphertext[i]);
                    
                    // Многоуровневое дешифрование в обратном порядке
                    for (let level = this.levels - 1; level >= 0; level--) {
                        element = this.multiply(inverses[level], this.multiply(element, keys[level]));
                    }
                    
                    decryptedBytes[i] = this.cliffordElementToByte(element);
                }
                
                const endTime = performance.now();
                
                return {
                    plaintext: new TextDecoder().decode(decryptedBytes),
                    performance: {
                        time: endTime - startTime
                    }
                };
            }
        }

        // Глобальные переменные
        const cipher = new CliffordAlgebraCipher();
        let currentCiphertext = null;

        // Шифрование текста
        async function encryptText() {
            const password = document.getElementById('password').value;
            const salt = document.getElementById('salt').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            const plaintext = document.getElementById('plaintext').value;
            
            if (!password || !salt || !plaintext) {
                alert('Заполните все поля');
                return;
            }

            try {
                const result = await cipher.encryptText(plaintext, password, salt, iterations);
                currentCiphertext = result.ciphertext;
                
                // Отображение зашифрованного текста (как raw bytes)
                const hexArray = Array.from(result.ciphertext).map(b => 
                    b.toString(16).padStart(2, '0')
                );
                
                document.getElementById('encryptedOutput').textContent = 
                    'Шифртекст (hex представление байтов):\n' + hexArray.join(' ');
                
                document.getElementById('originalSize').textContent = result.performance.originalSize;
                document.getElementById('encryptedSize').textContent = result.performance.encryptedSize;
                document.getElementById('encryptTime').textContent = result.performance.time.toFixed(2);
                
            } catch (error) {
                document.getElementById('encryptedOutput').textContent = 'Ошибка: ' + error.message;
            }
        }

        // Дешифрование текста
        async function decryptText() {
            if (!currentCiphertext) {
                alert('Сначала выполните шифрование');
                return;
            }

            const password = document.getElementById('password').value;
            const salt = document.getElementById('salt').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            
            try {
                const result = await cipher.decryptText(currentCiphertext, password, salt, iterations);
                
                document.getElementById('decryptedOutput').textContent = 
                    'Дешифрованный текст:\n' + result.plaintext;
                
                document.getElementById('decryptTime').textContent = result.performance.time.toFixed(2);
                
            } catch (error) {
                document.getElementById('decryptedOutput').textContent = 'Ошибка: ' + error.message;
            }
        }
    </script>
</body>
</html>
