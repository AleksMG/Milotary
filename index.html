<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Шифрование текста "Чёрный Лебедь" с PBKDF2</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #0d1117;
            color: #c9d1d9;
            line-height: 1.6;
        }
        h1 {
            color: #58a6ff;
            text-align: center;
            border-bottom: 2px solid #30363d;
            padding-bottom: 10px;
        }
        .container {
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
        }
        .input-group {
            margin: 15px 0;
        }
        textarea, input {
            width: 100%;
            background-color: #0d1117;
            color: #c9d1d9;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            resize: vertical;
        }
        button {
            background-color: #238636;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2ea043;
        }
        .output {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .stat-item {
            background-color: #21262d;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #58a6ff;
        }
        .progress {
            height: 20px;
            background-color: #21262d;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: #238636;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <h1>Шифрование текста с PBKDF2</h1>

    <div class="container">
        <h2>Параметры шифрования</h2>
        <div class="input-group">
            <label for="password">Пароль:</label>
            <input type="password" id="password" placeholder="Введите пароль" value="secret">
        </div>
        <div class="input-group">
            <label for="salt">Соль (hex):</label>
            <input type="text" id="salt" placeholder="Соль для PBKDF2" value="a1b2c3d4e5f6">
        </div>
        <div class="input-group">
            <label for="iterations">Итерации PBKDF2:</label>
            <input type="number" id="iterations" value="100000" min="10000" max="1000000">
        </div>
    </div>

    <div class="container">
        <h2>Исходный текст</h2>
        <div class="input-group">
            <textarea id="plaintext" rows="4" placeholder="Введите текст для шифрования">Привет мир! Это тест шифрования с PBKDF2.</textarea>
        </div>
        <button onclick="encryptText()">Зашифровать текст</button>
        <div id="progress" class="progress" style="display: none;">
            <div id="progressBar" class="progress-bar"></div>
        </div>
        <div class="output" id="encryptedOutput">Ожидание шифрования...</div>
        
        <div class="stats">
            <div class="stat-item">
                <div>Исходный размер</div>
                <div id="originalSize" class="stat-value">-</div>
                <div>байт</div>
            </div>
            <div class="stat-item">
                <div>Размер шифртекста</div>
                <div id="encryptedSize" class="stat-value">-</div>
                <div>байт</div>
            </div>
        </div>
    </div>

    <div class="container">
        <h2>Дешифрование</h2>
        <button onclick="decryptText()">Дешифровать текст</button>
        <div class="output" id="decryptedOutput">Ожидание дешифрования...</div>
        
        <div class="stats">
            <div class="stat-item">
                <div>Время шифрования</div>
                <div id="encryptTime" class="stat-value">-</div>
                <div>мс</div>
            </div>
            <div class="stat-item">
                <div>Время дешифрования</div>
                <div id="decryptTime" class="stat-value">-</div>
                <div>мс</div>
            </div>
        </div>
    </div>

    <script>
        class CliffordTextCipher {
            constructor() {
                this.prime = 65521n; // 16-битное простое число
                this.dimension = 8;   // Размерность 8
                this.levels = 9;      // Количество уровней
                this.keyLength = 32;  // Длина ключа в байтах
            }

            // Генерация ключей с помощью PBKDF2
            async generateKeysWithPBKDF2(password, salt, iterations) {
                const encoder = new TextEncoder();
                
                // Импорт пароля как ключа
                const keyMaterial = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    'PBKDF2',
                    false,
                    ['deriveBits']
                );
                
                // Генерация ключевого материала с помощью PBKDF2
                const derivedKey = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: this.hexToBytes(salt),
                        iterations: iterations,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    this.keyLength * 8
                );
                
                return new Uint8Array(derivedKey);
            }

            // Преобразование hex в bytes
            hexToBytes(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < bytes.length; i++) {
                    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
                }
                return bytes;
            }

            // Создание ключевых элементов из PBKDF2 материала
            createKeysFromPBKDF2(keyMaterial) {
                const keys = [];
                
                for (let level = 0; level < this.levels; level++) {
                    const key = new Map();
                    
                    // Используем разные части ключевого материала для каждого уровня
                    const offset = (level * 3) % (keyMaterial.length - 4);
                    
                    // Скалярная часть
                    key.set(0, BigInt(keyMaterial[offset] + 1));
                    
                    // Векторные части (4 компонента)
                    for (let i = 0; i < 4; i++) {
                        const byteValue = keyMaterial[offset + i + 1];
                        if (byteValue > 0) {
                            key.set(1 << i, BigInt(byteValue + 1));
                        }
                    }
                    
                    keys.push(key);
                }
                
                return keys;
            }

            // Преобразование байта в элемент алгебры
            byteToAlgebraElement(byte) {
                const element = new Map();
                
                // Скалярная часть - младшие 4 бита
                element.set(0, BigInt(byte & 0x0F) + 1n);
                
                // Векторная часть - старшие 4 бита
                const vectorPart = (byte >> 4) & 0x0F;
                if (vectorPart > 0) {
                    element.set(1 << (vectorPart - 1), 1n);
                }
                
                return element;
            }

            // Преобразование элемента алгебры в байт
            algebraElementToByte(element) {
                let scalar = Number(element.get(0) || 1n) - 1;
                let vector = 0;
                
                // Поиск векторной части
                for (const [key, value] of element) {
                    if (key !== 0 && value !== 0n) {
                        vector = Math.log2(Number(key)) + 1;
                        break;
                    }
                }
                
                return (vector << 4) | (scalar & 0x0F);
            }

            // Умножение элементов алгебры
            multiply(a, b) {
                const result = new Map();
                
                for (const [aKey, aVal] of a) {
                    for (const [bKey, bVal] of b) {
                        if (aVal === 0n || bVal === 0n) continue;
                        
                        const productKey = aKey ^ bKey;
                        let productVal = (aVal * bVal) % this.prime;
                        
                        // Учет антикоммутативности
                        const sign = this.calculateSign(aKey, bKey);
                        productVal = (productVal * sign) % this.prime;
                        
                        if (productVal < 0n) {
                            productVal += this.prime;
                        }
                        
                        if (productVal !== 0n) {
                            const current = result.get(productKey) || 0n;
                            result.set(productKey, (current + productVal) % this.prime);
                        }
                    }
                }
                
                return result;
            }

            // Вычисление знака произведения
            calculateSign(a, b) {
                if (a === 0 || b === 0) return 1n;
                
                let sign = 1n;
                const aBits = a.toString(2).padStart(this.dimension, '0').split('').reverse();
                const bBits = b.toString(2).padStart(this.dimension, '0').split('').reverse();
                
                for (let i = 0; i < this.dimension; i++) {
                    if (aBits[i] === '1') {
                        for (let j = i + 1; j < this.dimension; j++) {
                            if (bBits[j] === '1') {
                                sign = -sign;
                            }
                        }
                    }
                }
                
                return sign < 0n ? this.prime + sign : sign;
            }

            // Шифрование текста
            async encryptText(text, password, salt, iterations) {
                const startTime = performance.now();
                const textBytes = new TextEncoder().encode(text);
                const encryptedBytes = new Uint8Array(textBytes.length * 2);
                
                // Генерация ключей с PBKDF2
                const keyMaterial = await this.generateKeysWithPBKDF2(password, salt, iterations);
                const keys = this.createKeysFromPBKDF2(keyMaterial);
                
                for (let i = 0; i < textBytes.length; i++) {
                    const byte = textBytes[i];
                    
                    // Преобразование байта в элемент
                    let element = this.byteToAlgebraElement(byte);
                    
                    // Многоуровневое шифрование
                    for (let level = 0; level < this.levels; level++) {
                        const key = keys[level];
                        element = this.multiply(key, this.multiply(element, key));
                    }
                    
                    // Сохранение результата (2 байта)
                    const scalar = Number(element.get(0) || 1n) % 256;
                    let vector = 0;
                    
                    for (const [key, value] of element) {
                        if (key !== 0 && value !== 0n) {
                            vector = Math.log2(Number(key)) + 1;
                            break;
                        }
                    }
                    
                    encryptedBytes[i * 2] = scalar;
                    encryptedBytes[i * 2 + 1] = vector;
                }
                
                const endTime = performance.now();
                
                return {
                    ciphertext: encryptedBytes,
                    performance: {
                        time: endTime - startTime,
                        originalSize: textBytes.length,
                        encryptedSize: encryptedBytes.length
                    }
                };
            }

            // Дешифрование текста
            async decryptText(ciphertext, password, salt, iterations) {
                const startTime = performance.now();
                const decryptedBytes = new Uint8Array(ciphertext.length / 2);
                
                // Генерация ключей с PBKDF2 (таких же как при шифровании)
                const keyMaterial = await this.generateKeysWithPBKDF2(password, salt, iterations);
                const keys = this.createKeysFromPBKDF2(keyMaterial);
                
                for (let i = 0; i < decryptedBytes.length; i++) {
                    // Восстановление элемента из двух байт
                    const scalar = ciphertext[i * 2];
                    const vector = ciphertext[i * 2 + 1];
                    
                    let element = new Map();
                    element.set(0, BigInt(scalar) + 1n);
                    if (vector > 0) {
                        element.set(1 << (vector - 1), 1n);
                    }
                    
                    // Многоуровневое дешифрование (в обратном порядке)
                    for (let level = this.levels - 1; level >= 0; level--) {
                        const key = keys[level];
                        element = this.multiply(key, this.multiply(element, key));
                    }
                    
                    // Преобразование элемента обратно в байт
                    decryptedBytes[i] = this.algebraElementToByte(element);
                }
                
                const endTime = performance.now();
                
                return {
                    plaintext: new TextDecoder().decode(decryptedBytes),
                    performance: {
                        time: endTime - startTime
                    }
                };
            }
        }

        // Глобальные переменные
        const cipher = new CliffordTextCipher();
        let currentCiphertext = null;

        // Обновление прогресса
        function updateProgress(percentage) {
            const progress = document.getElementById('progress');
            const progressBar = document.getElementById('progressBar');
            
            progress.style.display = 'block';
            progressBar.style.width = percentage + '%';
        }

        // Шифрование текста
        async function encryptText() {
            const password = document.getElementById('password').value;
            const salt = document.getElementById('salt').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            const plaintext = document.getElementById('plaintext').value;
            
            if (!password || !salt || !plaintext) {
                alert('Заполните все поля');
                return;
            }

            try {
                updateProgress(10);
                const result = await cipher.encryptText(plaintext, password, salt, iterations);
                currentCiphertext = result.ciphertext;
                
                updateProgress(100);
                
                // Отображение результатов
                document.getElementById('encryptedOutput').textContent = 
                    'Шифртекст (hex):\n' + Array.from(result.ciphertext)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ');
                
                document.getElementById('originalSize').textContent = result.performance.originalSize;
                document.getElementById('encryptedSize').textContent = result.performance.encryptedSize;
                document.getElementById('encryptTime').textContent = result.performance.time.toFixed(2);
                
                setTimeout(() => {
                    document.getElementById('progress').style.display = 'none';
                }, 1000);
                
            } catch (error) {
                document.getElementById('encryptedOutput').textContent = 'Ошибка: ' + error.message;
                document.getElementById('progress').style.display = 'none';
            }
        }

        // Дешифрование текста
        async function decryptText() {
            if (!currentCiphertext) {
                alert('Сначала выполните шифрование');
                return;
            }

            const password = document.getElementById('password').value;
            const salt = document.getElementById('salt').value;
            const iterations = parseInt(document.getElementById('iterations').value);
            
            try {
                updateProgress(50);
                const result = await cipher.decryptText(currentCiphertext, password, salt, iterations);
                
                updateProgress(100);
                
                document.getElementById('decryptedOutput').textContent = 
                    'Дешифрованный текст:\n' + result.plaintext;
                
                document.getElementById('decryptTime').textContent = result.performance.time.toFixed(2);
                
                setTimeout(() => {
                    document.getElementById('progress').style.display = 'none';
                }, 1000);
                
            } catch (error) {
                document.getElementById('decryptedOutput').textContent = 'Ошибка: ' + error.message;
                document.getElementById('progress').style.display = 'none';
            }
        }
    </script>
</body>
</html>
