<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</title>
    <style>
        :root {
            --primary: #1a365d;
            --secondary: #2a69ac;
            --accent: #e53e3e;
            --success: #38a169;
            --warning: #d69e2e;
            --light: #f7fafc;
            --dark: #2d3748;
            --border: #e2e8f0;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Fira Code', 'Courier New', monospace;
        }
        
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #0f172a 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1.6;
            color: #e2e8f0;
        }
        
        .container {
            background: rgba(26, 32, 44, 0.95);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            padding: 40px;
            width: 100%;
            max-width: 1400px;
            margin: 20px;
            border: 1px solid #2d3748;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }
        
        h1 {
            color: white;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
            background: linear-gradient(45deg, #63b3ed, #4299e1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        h2 {
            color: #90cdf4;
            margin: 25px 0 15px;
            font-size: 1.8rem;
        }
        
        h3 {
            color: #a0aec0;
            margin: 20px 0 12px;
            font-size: 1.4rem;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 968px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: #2d3748;
            border-radius: 12px;
            padding: 28px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #4a5568;
        }
        
        .input-group {
            margin-bottom: 24px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #e2e8f0;
            font-size: 0.95em;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 14px;
            border: 2px solid #4a5568;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.2s ease;
            background: #1a202c;
            color: #e2e8f0;
        }
        
        input:focus, textarea:focus, select:focus {
            border-color: #4299e1;
            outline: none;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }
        
        textarea {
            min-height: 140px;
            resize: vertical;
            line-height: 1.5;
        }
        
        .btn-group {
            display: flex;
            gap: 16px;
            margin: 28px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 140px;
        }
        
        .btn-encrypt {
            background: linear-gradient(45deg, #2b6cb0, #2c5282);
            color: white;
        }
        
        .btn-decrypt {
            background: linear-gradient(45deg, #e53e3e, #c53030);
            color: white;
        }
        
        .btn-generate {
            background: linear-gradient(45deg, #38a169, #2f855a);
            color: white;
        }
        
        .process-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
            justify-content: center;
            align-items: center;
        }
        
        .byte-block {
            background: #4a5568;
            border-radius: 6px;
            padding: 12px;
            min-width: 80px;
            text-align: center;
            position: relative;
            transition: all 0.3s;
        }
        
        .original-byte {
            background: #2b6cb0;
        }
        
        .homophone-byte {
            background: #38a169;
        }
        
        .id-byte {
            background: #f6ad55;
            color: #1a202c;
        }
        
        .arrow {
            font-size: 24px;
            display: flex;
            align-items: center;
            color: #90cdf4;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin: 24px 0;
        }
        
        .stat-card {
            background: #1a202c;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #4a5568;
        }
        
        .stat-value {
            font-size: 1.4em;
            font-weight: 700;
            color: #63b3ed;
            margin: 8px 0;
        }
        
        .byte-table {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: #1a202c;
            border-radius: 8px;
        }
        
        .byte-item {
            background: #2d3748;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            font-size: 14px;
            text-align: center;
        }
        
        .byte-value {
            font-weight: bold;
            color: #63b3ed;
        }
        
        .warning {
            background: #742a2a;
            border: 1px solid #e53e3e;
            color: #fed7d7;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 0.9em;
        }
        
        .success {
            background: #22543d;
            border: 1px solid #38a169;
            color: #c6f6d5;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 0.9em;
        }
        
        .hex-view {
            font-family: 'Fira Code', monospace;
            background: #1a202c;
            padding: 16px;
            border-radius: 6px;
            border: 1px solid #4a5568;
            overflow-x: auto;
            line-height: 1.8;
            white-space: nowrap;
        }
        
        .hex-byte {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            border-radius: 3px;
            background: #2d3748;
        }
        
        .original-hex {
            background: #2b6cb0;
        }
        
        .homophone-hex {
            background: #38a169;
        }
        
        .id-hex {
            background: #f6ad55;
            color: #1a202c;
        }
        
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }
        
        .status-success {
            background: #22543d;
            color: #c6f6d5;
        }
        
        .status-error {
            background: #742a2a;
            color: #fed7d7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</h1>
            <p>–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç—å ‚Ä¢ –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</p>
        </div>

        <div class="warning">
            <strong>‚ö†Ô∏è –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:</strong> –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∞–Ω –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è.
        </div>

        <div class="grid">
            <div class="card">
                <h2>üîë –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏—Å—Ç–µ–º—ã</h2>
                <div class="input-group">
                    <label for="masterKey">–ú–∞—Å—Ç–µ—Ä-–∫–ª—é—á (–ª—é–±–∞—è —Å—Ç—Ä–æ–∫–∞):</label>
                    <input type="text" id="masterKey" value="–°–µ–∫—Ä–µ—Ç–Ω—ã–π–ö–ª—é—á2024!" placeholder="–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á">
                </div>
                
                <div class="input-group">
                    <label for="homophoneCount">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–º–æ—Ñ–æ–Ω–æ–≤ –Ω–∞ –±–∞–π—Ç:</label>
                    <select id="homophoneCount">
                        <option value="2">2 –æ–º–æ—Ñ–æ–Ω–∞ (1 –±–∏—Ç ID)</option>
                        <option value="4" selected>4 –æ–º–æ—Ñ–æ–Ω–∞ (2 –±–∏—Ç–∞ ID)</option>
                        <option value="8">8 –æ–º–æ—Ñ–æ–Ω–æ–≤ (3 –±–∏—Ç–∞ ID)</option>
                        <option value="16">16 –æ–º–æ—Ñ–æ–Ω–æ–≤ (4 –±–∏—Ç–∞ ID)</option>
                    </select>
                </div>
                
                <button class="btn-generate" onclick="generateNewKey()">
                    <span class="icon">üé≤</span> –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á
                </button>
                
                <div id="statusKey" class="status status-success">–ö–ª—é—á —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</div>
            </div>

            <div class="card">
                <h2>üìù –ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ</h2>
                <div class="input-group">
                    <label for="inputText">–¢–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
                    <textarea id="inputText">–ü—Ä–∏–≤–µ—Ç –º–∏—Ä! Hello world! 123 –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞—Ç–∏–º–æ—Å—Ç–∏</textarea>
                </div>
                
                <div class="input-group">
                    <label>–ë–∞–π—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (HEX):</label>
                    <div class="hex-view" id="hexOriginal"></div>
                </div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">–†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö</div>
                        <div class="stat-value" id="dataSize">0 B</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">–≠–Ω—Ç—Ä–æ–ø–∏—è</div>
                        <div class="stat-value" id="dataEntropy">0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="btn-group">
            <button class="btn-encrypt" onclick="encryptData()">
                <span class="icon">üîí</span> –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
            </button>
            <button class="btn-decrypt" onclick="decryptData()">
                <span class="icon">üîì</span> –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
            </button>
        </div>

        <div class="card">
            <h2>üìä –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</h2>
            <div id="processVisualization" class="process-visualization">
                <div class="byte-block original-byte">0x00</div>
                <div class="arrow">‚Üí</div>
                <div class="byte-block id-byte">ID:0</div>
                <div class="byte-block homophone-byte">0x00</div>
            </div>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">–†–∞–∑–º–µ—Ä –ø–æ—Å–ª–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</div>
                    <div class="stat-value" id="encryptedSize">0 B</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">–≠–Ω—Ç—Ä–æ–ø–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞</div>
                    <div class="stat-value" id="encryptedEntropy">0.00</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è</div>
                    <div class="stat-value" id="expansionRatio">0%</div>
                </div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>üìã –†–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏</h2>
                <div class="input-group">
                    <label for="outputText">–†–µ–∑—É–ª—å—Ç–∞—Ç (HEX):</label>
                    <textarea id="outputText" readonly placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..."></textarea>
                </div>
                
                <div class="input-group">
                    <label>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–π—Ç–æ–≤:</label>
                    <div class="hex-view" id="hexOutput"></div>
                </div>
                
                <div id="statusProcess" class="status">–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏...</div>
            </div>

            <div class="card">
                <h2>üîÑ –¢–∞–±–ª–∏—Ü–∞ –±–∞–π—Ç–æ–≤—ã—Ö –æ–º–æ—Ñ–æ–Ω–æ–≤</h2>
                <div class="input-group">
                    <label>–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–º–æ—Ñ–æ–Ω—ã (–ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç–æ–≤):</label>
                    <div class="byte-table" id="byteTablePreview">
                        <div class="byte-item">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    </div>
                </div>
                
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-label">–ë–∞–π—Ç–æ–≤ –≤ —Ç–∞–±–ª–∏—Ü–µ</div>
                        <div class="stat-value" id="tableSize">256</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">–í—Å–µ–≥–æ –æ–º–æ—Ñ–æ–Ω–æ–≤</div>
                        <div class="stat-value" id="totalHomophones">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class FixedByteHomophonicCipher {
            constructor() {
                this.homophoneTable = new Map();
                this.reverseTable = new Map();
            }

            // –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π PRNG –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
            createKeyDerivedRNG(key) {
                let seed = 0;
                const encoder = new TextEncoder();
                const keyBytes = encoder.encode(key);
                
                for (let i = 0; i < keyBytes.length; i++) {
                    seed = (seed << 5) - seed + keyBytes[i];
                    seed = seed & seed; // Convert to 32-bit integer
                }
                
                return {
                    next: () => {
                        seed = (seed * 1664525 + 1013904223) % 4294967296;
                        return seed / 4294967296;
                    },
                    nextInt: (max) => Math.floor(this.next() * max)
                };
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤ –¥–ª—è –≤—Å–µ—Ö 256 –±–∞–π—Ç–æ–≤
            generateHomophoneTable(masterKey, homophonesPerByte = 4) {
                const table = new Map();
                const reverse = new Map();
                const rng = this.createKeyDerivedRNG(masterKey);
                
                // –°–æ–∑–¥–∞–µ–º –ø—É–ª –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –±–∞–π—Ç–æ–≤ (0-255)
                const allBytes = Array.from({length: 256}, (_, i) => i);
                
                // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –ø—É–ª –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞
                for (let i = allBytes.length - 1; i > 0; i--) {
                    const j = Math.floor(rng.next() * (i + 1));
                    [allBytes[i], allBytes[j]] = [allBytes[j], allBytes[i]];
                }
                
                let byteIndex = 0;
                
                // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –±–∞–π—Ç–∞ (0-255)
                for (let byteValue = 0; byteValue < 256; byteValue++) {
                    const homophones = [];
                    
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ–º–æ—Ñ–æ–Ω—ã –¥–ª—è —ç—Ç–æ–≥–æ –±–∞–π—Ç–∞
                    for (let i = 0; i < homophonesPerByte; i++) {
                        if (byteIndex >= allBytes.length) {
                            // –ï—Å–ª–∏ –ø—É–ª –∏—Å—á–µ—Ä–ø–∞–Ω, –Ω–∞—á–∏–Ω–∞–µ–º —Å–Ω–∞—á–∞–ª–∞
                            byteIndex = 0;
                            for (let i = allBytes.length - 1; i > 0; i--) {
                                const j = Math.floor(rng.next() * (i + 1));
                                [allBytes[i], allBytes[j]] = [allBytes[j], allBytes[i]];
                            }
                        }
                        
                        const homophone = allBytes[byteIndex++];
                        homophones.push(homophone);
                        
                        // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω—É—é —Ç–∞–±–ª–∏—Ü—É: homophone -> (original, index)
                        reverse.set(homophone, { original: byteValue, index: i });
                    }
                    
                    table.set(byteValue, homophones);
                }
                
                this.homophoneTable = table;
                this.reverseTable = reverse;
                return table;
            }

            // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º ID –æ–º–æ—Ñ–æ–Ω–æ–≤
            encrypt(data, masterKey) {
                const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
                this.generateHomophoneTable(masterKey, homophonesPerByte);
                
                const rng = this.createKeyDerivedRNG(masterKey + data.length);
                const result = new Uint8Array(data.length * 2);
                const processSteps = [];
                
                for (let i = 0; i < data.length; i++) {
                    const originalByte = data[i];
                    
                    if (!this.homophoneTable.has(originalByte)) {
                        // –ï—Å–ª–∏ –±–∞–π—Ç–∞ –Ω–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ, –ø—Ä–æ—Å—Ç–æ –∫–æ–ø–∏—Ä—É–µ–º –µ–≥–æ
                        result[i * 2] = 255; // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π ID –¥–ª—è –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö –±–∞–π—Ç–æ–≤
                        result[i * 2 + 1] = originalByte;
                        processSteps.push({
                            original: originalByte,
                            homophone: originalByte,
                            id: 255,
                            idBits: '11111111'
                        });
                        continue;
                    }
                    
                    const homophones = this.homophoneTable.get(originalByte);
                    const homophoneIndex = Math.floor(rng.next() * homophones.length);
                    const selectedHomophone = homophones[homophoneIndex];
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º ID –∏ –æ–º–æ—Ñ–æ–Ω
                    result[i * 2] = homophoneIndex;
                    result[i * 2 + 1] = selectedHomophone;
                    
                    processSteps.push({
                        original: originalByte,
                        homophone: selectedHomophone,
                        id: homophoneIndex,
                        idBits: homophoneIndex.toString(2).padStart(Math.ceil(Math.log2(homophones.length)), '0')
                    });
                }
                
                return { encryptedData: result, processSteps };
            }

            // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            decrypt(encryptedData, masterKey) {
                const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
                this.generateHomophoneTable(masterKey, homophonesPerByte);
                
                if (encryptedData.length % 2 !== 0) {
                    throw new Error("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: –¥–ª–∏–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫—Ä–∞—Ç–Ω–æ–π 2");
                }
                
                const result = new Uint8Array(encryptedData.length / 2);
                
                for (let i = 0; i < encryptedData.length; i += 2) {
                    const idBits = encryptedData[i];
                    const homophoneByte = encryptedData[i + 1];
                    
                    if (idBits === 255) {
                        // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å–ª—É—á–∞–π: –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–π –±–∞–π—Ç
                        result[i / 2] = homophoneByte;
                        continue;
                    }
                    
                    if (!this.reverseTable.has(homophoneByte)) {
                        throw new Error(`–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ–º–æ—Ñ–æ–Ω: 0x${homophoneByte.toString(16)}`);
                    }
                    
                    const { original, index } = this.reverseTable.get(homophoneByte);
                    
                    if (index !== idBits) {
                        throw new Error(`–ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ID: –æ–∂–∏–¥–∞–ª–æ—Å—å ${index}, –ø–æ–ª—É—á–µ–Ω–æ ${idBits}`);
                    }
                    
                    result[i / 2] = original;
                }
                
                return result;
            }

            // –†–∞—Å—á–µ—Ç —ç–Ω—Ç—Ä–æ–ø–∏–∏ –¥–∞–Ω–Ω—ã—Ö
            calculateEntropy(data) {
                const freq = new Array(256).fill(0);
                for (const byte of data) {
                    freq[byte]++;
                }
                
                let entropy = 0;
                const length = data.length;
                
                for (const count of freq) {
                    if (count > 0) {
                        const p = count / length;
                        entropy -= p * Math.log2(p);
                    }
                }
                
                return entropy;
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        const cipher = new FixedByteHomophonicCipher();

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –∫–ª—é—á–∞
        function generateNewKey() {
            const randomBytes = new Uint8Array(16);
            crypto.getRandomValues(randomBytes);
            const key = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            document.getElementById('masterKey').value = key;
            updateStatus('–ö–ª—é—á —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω', 'success');
            updateByteTable();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤
        function updateByteTable() {
            const masterKey = document.getElementById('masterKey').value;
            const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
            
            try {
                cipher.generateHomophoneTable(masterKey, homophonesPerByte);
                displayByteTablePreview();
                updateStatus('–¢–∞–±–ª–∏—Ü–∞ –æ–º–æ—Ñ–æ–Ω–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω–∞', 'success');
            } catch (error) {
                console.error('Error generating homophone table:', error);
                updateStatus('–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–∞–±–ª–∏—Ü—ã: ' + error.message, 'error');
            }
        }

        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–µ–≤—å—é —Ç–∞–±–ª–∏—Ü—ã –æ–º–æ—Ñ–æ–Ω–æ–≤
        function displayByteTablePreview() {
            const preview = document.getElementById('byteTablePreview');
            preview.innerHTML = '';
            
            const homophonesPerByte = parseInt(document.getElementById('homophoneCount').value);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 16 –±–∞–π—Ç–æ–≤ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
            for (let byteValue = 0; byteValue < 16; byteValue++) {
                const homophones = cipher.homophoneTable.get(byteValue) || [];
                
                const item = document.createElement('div');
                item.className = 'byte-item';
                item.innerHTML = `
                    <div><span class="byte-value">0x${byteValue.toString(16).padStart(2, '0')}</span> ‚Üí</div>
                    ${homophones.map((b, i) => 
                        `<div>ID:${i} ‚Üí 0x${b.toString(16).padStart(2, '0')}</div>`
                    ).join('')}
                `;
                preview.appendChild(item);
            }
            
            document.getElementById('totalHomophones').textContent = 256 * homophonesPerByte;
        }

        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –±–∞–π—Ç–æ–≤ –≤ HEX-—Ñ–æ—Ä–º–∞—Ç–µ
        function displayHexData(data, elementId, classNames = []) {
            const container = document.getElementById(elementId);
            container.innerHTML = '';
            
            for (let i = 0; i < Math.min(data.length, 50); i++) {
                const byteElement = document.createElement('span');
                byteElement.className = `hex-byte ${classNames[i] || ''}`;
                byteElement.textContent = data[i].toString(16).padStart(2, '0');
                container.appendChild(byteElement);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–±–µ–ª –º–µ–∂–¥—É –ø–∞—Ä–∞–º–∏ –±–∞–π—Ç–æ–≤ (ID + –æ–º–æ—Ñ–æ–Ω)
                if (i % 2 === 1 && i < data.length - 1) {
                    container.appendChild(document.createTextNode(' '));
                }
            }
            
            if (data.length > 50) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = ` ... (–µ—â—ë ${data.length - 50} –±–∞–π—Ç)`;
                ellipsis.style.color = '#a0aec0';
                container.appendChild(ellipsis);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        function updateStatus(message, type = '') {
            const statusElement = document.getElementById('statusProcess');
            statusElement.textContent = message;
            statusElement.className = `status ${type ? 'status-' + type : ''}`;
        }

        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        function encryptData() {
            const inputText = document.getElementById('inputText').value;
            const masterKey = document.getElementById('masterKey').value;
            
            if (!inputText) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }
            
            if (!masterKey) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á', 'error');
                return;
            }
            
            try {
                updateStatus('–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ...');
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –≤ –±–∞–π—Ç—ã
                const encoder = new TextEncoder();
                const data = encoder.encode(inputText);
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –±–∞–π—Ç—ã
                displayHexData(data, 'hexOriginal', Array(data.length).fill('original-hex'));
                
                // –®–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
                const { encryptedData, processSteps } = cipher.encrypt(data, masterKey);
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                const outputHex = Array.from(encryptedData).map(b => b.toString(16).padStart(2, '0')).join(' ');
                document.getElementById('outputText').value = outputHex;
                
                // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –∫–ª–∞—Å—Å—ã –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ (ID + –æ–º–æ—Ñ–æ–Ω —á–µ—Ä–µ–¥—É—é—Ç—Å—è)
                const hexClasses = [];
                for (let i = 0; i < encryptedData.length; i++) {
                    hexClasses.push(i % 2 === 0 ? 'id-hex' : 'homophone-hex');
                }
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–∞–π—Ç—ã
                displayHexData(encryptedData, 'hexOutput', hexClasses);
                
                // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ—Ü–µ—Å—Å
                visualizeProcess(processSteps);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
                updateMetrics(data, encryptedData);
                
                updateStatus('–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ!', 'success');
            } catch (error) {
                console.error('Encryption error:', error);
                updateStatus('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        function decryptData() {
            const inputHex = document.getElementById('inputText').value.trim();
            const masterKey = document.getElementById('masterKey').value;
            
            if (!inputHex) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ HEX-–¥–∞–Ω–Ω—ã–µ –¥–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                return;
            }
            
            if (!masterKey) {
                updateStatus('–í–≤–µ–¥–∏—Ç–µ –º–∞—Å—Ç–µ—Ä-–∫–ª—é—á', 'error');
                return;
            }
            
            try {
                updateStatus('–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ...');
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º HEX-—Å—Ç—Ä–æ–∫—É –≤ –±–∞–π—Ç—ã
                const hexBytes = inputHex.split(/\s+/);
                const encryptedData = new Uint8Array(hexBytes.map(byte => {
                    const parsed = parseInt(byte, 16);
                    if (isNaN(parsed) || parsed < 0 || parsed > 255) {
                        throw new Error(`–ù–µ–≤–µ—Ä–Ω—ã–π HEX-–±–∞–π—Ç: ${byte}`);
                    }
                    return parsed;
                }));
                
                if (encryptedData.length % 2 !== 0) {
                    throw new Error("–î–ª–∏–Ω–∞ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫—Ä–∞—Ç–Ω–æ–π 2");
                }
                
                // –î–µ—à–∏—Ñ—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
                const decryptedData = cipher.decrypt(encryptedData, masterKey);
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –±–∞–π—Ç—ã –æ–±—Ä–∞—Ç–Ω–æ –≤ —Ç–µ–∫—Å—Ç
                const decoder = new TextDecoder();
                const decryptedText = decoder.decode(decryptedData);
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                document.getElementById('outputText').value = decryptedText;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
                updateMetrics(encryptedData, decryptedData);
                
                updateStatus('–î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ!', 'success');
            } catch (error) {
                console.error('Decryption error:', error);
                updateStatus('–û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + error.message, 'error');
            }
        }

        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
        function visualizeProcess(processSteps) {
            const container = document.getElementById('processVisualization');
            container.innerHTML = '';
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 5 –±–∞–π—Ç–æ–≤ –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
            const stepsToShow = processSteps.slice(0, 5);
            
            stepsToShow.forEach((step, index) => {
                if (index > 0) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.textContent = '‚Üí';
                    container.appendChild(arrow);
                }
                
                const originalBlock = document.createElement('div');
                originalBlock.className = 'byte-block original-byte';
                originalBlock.textContent = `0x${step.original.toString(16).padStart(2, '0')}`;
                container.appendChild(originalBlock);
                
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.textContent = '‚Üí';
                container.appendChild(arrow);
                
                const idBlock = document.createElement('div');
                idBlock.className = 'byte-block id-byte';
                idBlock.textContent = `ID:${step.id}`;
                container.appendChild(idBlock);
                
                const homophoneBlock = document.createElement('div');
                homophoneBlock.className = 'byte-block homophone-byte';
                homophoneBlock.textContent = `0x${step.homophone.toString(16).padStart(2, '0')}`;
                container.appendChild(homophoneBlock);
            });
            
            if (processSteps.length > 5) {
                const ellipsis = document.createElement('div');
                ellipsis.style.cssText = 'padding: 10px; color: #a0aec0; font-style: italic;';
                ellipsis.textContent = `... –∏ –µ—â—ë ${processSteps.length - 5} –±–∞–π—Ç–æ–≤`;
                container.appendChild(ellipsis);
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
        function updateMetrics(originalData, processedData) {
            if (originalData && processedData) {
                const originalSize = originalData.length;
                const processedSize = processedData.length;
                const expansion = ((processedSize - originalSize) / originalSize * 100).toFixed(1);
                
                document.getElementById('dataSize').textContent = originalSize + ' B';
                document.getElementById('encryptedSize').textContent = processedSize + ' B';
                document.getElementById('expansionRatio').textContent = expansion + '%';
                
                document.getElementById('dataEntropy').textContent = cipher.calculateEntropy(originalData).toFixed(2);
                document.getElementById('encryptedEntropy').textContent = cipher.calculateEntropy(processedData).toFixed(2);
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        window.onload = function() {
            generateNewKey();
            
            // –°–ª—É—à–∞—Ç–µ–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π
            document.getElementById('masterKey').addEventListener('input', updateByteTable);
            document.getElementById('homophoneCount').addEventListener('change', updateByteTable);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            const inputText = document.getElementById('inputText').value;
            const encoder = new TextEncoder();
            const data = encoder.encode(inputText);
            displayHexData(data, 'hexOriginal', Array(data.length).fill('original-hex'));
            updateMetrics(data, data);
        };
    </script>
</body>
</html>
