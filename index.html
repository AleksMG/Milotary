<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clifford Cipher - Точная реализация</title>
    <style>
        :root {
            --ios-bg: #f5f5f7;
            --ios-card: #ffffff;
            --ios-text: #1d1d1f;
            --ios-secondary: #86868b;
            --ios-blue: #007aff;
            --ios-green: #34c759;
            --ios-red: #ff3b30;
            --ios-border: #e5e5ea;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--ios-bg);
            color: var(--ios-text);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--ios-blue);
            color: white;
            border-radius: 16px;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .card {
            background: var(--ios-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--ios-border);
        }
        
        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        textarea, input {
            width: 100%;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid var(--ios-border);
            background: var(--ios-card);
            color: var(--ios-text);
            font-family: monospace;
            font-size: 16px;
            resize: vertical;
            margin-bottom: 15px;
        }
        
        .btn-group {
            display: flex;
            gap: 12px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        button {
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            background: var(--ios-blue);
            color: white;
            flex: 1;
            min-width: 120px;
        }
        
        button:hover {
            opacity: 0.9;
        }
        
        .output {
            background: var(--ios-bg);
            padding: 15px;
            border-radius: 12px;
            margin-top: 15px;
            min-height: 100px;
            font-family: monospace;
            white-space: pre-wrap;
            border: 1px solid var(--ios-border);
            font-size: 14px;
        }
        
        .status {
            padding: 12px;
            border-radius: 12px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
        }
        
        .success {
            background: rgba(52, 199, 89, 0.1);
            border: 1px solid var(--ios-green);
            color: var(--ios-green);
        }
        
        .error {
            background: rgba(255, 59, 48, 0.1);
            border: 1px solid var(--ios-red);
            color: var(--ios-red);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Clifford Cipher</h1>
            <p>Точная реализация без сокращений</p>
        </div>
        
        <div class="card">
            <div class="card-title">Исходный текст</div>
            <textarea id="inputText" rows="4">Тестовое сообщение</textarea>
            
            <div class="card-title">Ключ шифрования</div>
            <input type="text" id="encryptionKey" value="StrongKey123456">
        </div>
        
        <div class="btn-group">
            <button onclick="encryptText()">Зашифровать</button>
            <button onclick="decryptText()">Расшифровать</button>
            <button onclick="testReversibility()">Тест обратимости</button>
        </div>
        
        <div class="card">
            <div class="card-title">Результаты</div>
            <div class="output" id="resultOutput">—</div>
            <div id="validationOutput" class="status">—</div>
        </div>
    </div>

    <script>
        // Полная реализация алгебры Клиффорда
        class CliffordAlgebra {
            constructor() {
                this.dimension = 4;
                this.metric = [1, 1, 1, -1];
                this.basisCount = 16;
                this.multiplicationTable = this.generateMultiplicationTable();
            }
            
            generateMultiplicationTable() {
                const table = new Array(this.basisCount);
                for (let i = 0; i < this.basisCount; i++) {
                    table[i] = new Array(this.basisCount);
                    for (let j = 0; j < this.basisCount; j++) {
                        table[i][j] = this.multiplyBasisElements(i, j);
                    }
                }
                return table;
            }
            
            multiplyBasisElements(a, b) {
                if (a === 0) return { value: b, sign: 1 };
                if (b === 0) return { value: a, sign: 1 };
                
                const aVectors = this.getBasisVectors(a);
                const bVectors = this.getBasisVectors(b);
                
                let resultVectors = [...aVectors];
                let sign = 1;
                
                for (const bVec of bVectors) {
                    let insertPos = resultVectors.length;
                    
                    for (let i = 0; i < resultVectors.length; i++) {
                        if (resultVectors[i] === bVec) {
                            sign *= this.metric[bVec];
                            resultVectors.splice(i, 1);
                            insertPos = -1;
                            break;
                        } else if (resultVectors[i] > bVec) {
                            insertPos = i;
                            break;
                        }
                    }
                    
                    if (insertPos >= 0) {
                        sign *= Math.pow(-1, resultVectors.length - insertPos);
                        resultVectors.splice(insertPos, 0, bVec);
                    }
                }
                
                let resultValue = 0;
                for (const vec of resultVectors) {
                    resultValue |= (1 << vec);
                }
                
                return { value: resultValue, sign: sign };
            }
            
            getBasisVectors(x) {
                const vectors = [];
                for (let i = 0; i < this.dimension; i++) {
                    if (x & (1 << i)) {
                        vectors.push(i);
                    }
                }
                return vectors.sort((a, b) => a - b);
            }
            
            multiply(a, b) {
                const result = new Array(this.basisCount).fill(0);
                
                for (let i = 0; i < this.basisCount; i++) {
                    if (Math.abs(a[i]) < 1e-10) continue;
                    
                    for (let j = 0; j < this.basisCount; j++) {
                        if (Math.abs(b[j]) < 1e-10) continue;
                        
                        const product = this.multiplicationTable[i][j];
                        const coefficient = a[i] * b[j] * product.sign;
                        result[product.value] = (result[product.value] || 0) + coefficient;
                    }
                }
                
                return result;
            }
            
            inverse(mv) {
                const reversed = this.reverse(mv);
                const norm = this.multiply(mv, reversed);
                
                if (Math.abs(norm[0]) < 1e-10) {
                    throw new Error("Невозможно обратить мультивектор");
                }
                
                const result = new Array(this.basisCount).fill(0);
                for (let i = 0; i < this.basisCount; i++) {
                    result[i] = reversed[i] / norm[0];
                }
                
                return result;
            }
            
            reverse(mv) {
                const result = [...mv];
                for (let i = 1; i < this.basisCount; i++) {
                    const vectors = this.getBasisVectors(i);
                    if (vectors.length % 2 === 1) {
                        result[i] = -result[i];
                    }
                }
                return result;
            }
            
            bytesToMultivector(bytes) {
                const mv = new Array(this.basisCount).fill(0);
                for (let i = 0; i < this.basisCount; i++) {
                    mv[i] = (bytes[i] - 128) / 128;
                }
                return mv;
            }
            
            multivectorToBytes(mv) {
                const bytes = new Uint8Array(this.basisCount);
                for (let i = 0; i < this.basisCount; i++) {
                    const value = Math.round(mv[i] * 128 + 128);
                    if (value < 0 || value > 255) {
                        throw new Error(`Значение компоненты ${i} вышло за пределы: ${value}`);
                    }
                    bytes[i] = value;
                }
                return bytes;
            }
        }

        class CliffordCipher {
            constructor() {
                this.algebra = new CliffordAlgebra();
            }
            
            async encryptText(text, keyString) {
                const keyBytes = new TextEncoder().encode(keyString);
                const textBytes = new TextEncoder().encode(text);
                
                // Дополняем ключ до 16 байт
                const paddedKey = this.padTo16Bytes(keyBytes);
                const keyMultivector = this.algebra.bytesToMultivector(paddedKey);
                
                const resultBytes = new Uint8Array(textBytes.length);
                
                for (let i = 0; i < textBytes.length; i++) {
                    const byteMV = this.algebra.bytesToMultivector(new Uint8Array([textBytes[i]]).fill(0, 1));
                    const kInverse = this.algebra.inverse(keyMultivector);
                    
                    const kp = this.algebra.multiply(keyMultivector, byteMV);
                    const encryptedMV = this.algebra.multiply(kp, kInverse);
                    
                    const encryptedBytes = this.algebra.multivectorToBytes(encryptedMV);
                    resultBytes[i] = encryptedBytes[0];
                }
                
                return Array.from(resultBytes);
            }
            
            async decryptText(encryptedBytes, keyString) {
                const keyBytes = new TextEncoder().encode(keyString);
                const paddedKey = this.padTo16Bytes(keyBytes);
                const keyMultivector = this.algebra.bytesToMultivector(paddedKey);
                
                const resultBytes = new Uint8Array(encryptedBytes.length);
                
                for (let i = 0; i < encryptedBytes.length; i++) {
                    const byteMV = this.algebra.bytesToMultivector(new Uint8Array([encryptedBytes[i]]).fill(0, 1));
                    const kInverse = this.algebra.inverse(keyMultivector);
                    
                    const kInverseC = this.algebra.multiply(kInverse, byteMV);
                    const decryptedMV = this.algebra.multiply(kInverseC, keyMultivector);
                    
                    const decryptedBytes = this.algebra.multivectorToBytes(decryptedMV);
                    resultBytes[i] = decryptedBytes[0];
                }
                
                return new TextDecoder().decode(resultBytes);
            }
            
            padTo16Bytes(bytes) {
                const result = new Uint8Array(16);
                for (let i = 0; i < 16; i++) {
                    result[i] = bytes[i % bytes.length];
                }
                return result;
            }
            
            async testReversibility() {
                const testText = "Test";
                const testKey = "Key";
                
                try {
                    const encrypted = await this.encryptText(testText, testKey);
                    const decrypted = await this.decryptText(encrypted, testKey);
                    
                    return {
                        success: decrypted === testText,
                        original: testText,
                        decrypted: decrypted
                    };
                } catch (error) {
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }
        }

        const cipher = new CliffordCipher();

        async function encryptText() {
            try {
                const text = document.getElementById('inputText').value;
                const key = document.getElementById('encryptionKey').value;
                
                const encrypted = await cipher.encryptText(text, key);
                document.getElementById('resultOutput').textContent = 
                    `Зашифрованные байты:\n[${encrypted.join(', ')}]`;
                
                document.getElementById('validationOutput').textContent = '✓ Шифрование успешно';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('validationOutput').textContent = `✗ Ошибка: ${error.message}`;
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        async function decryptText() {
            try {
                const text = document.getElementById('inputText').value;
                const key = document.getElementById('encryptionKey').value;
                
                // Парсим байты из текста
                const byteMatch = text.match(/\[([^\]]+)\]/);
                let bytes;
                
                if (byteMatch) {
                    bytes = byteMatch[1].split(',').map(b => parseInt(b.trim()));
                } else {
                    // Если это не байты, пытаемся шифровать
                    const encrypted = await cipher.encryptText(text, key);
                    const decrypted = await cipher.decryptText(encrypted, key);
                    
                    document.getElementById('resultOutput').textContent = 
                        `Расшифрованный текст: ${decrypted}`;
                    document.getElementById('validationOutput').textContent = '✓ Дешифрование успешно';
                    document.getElementById('validationOutput').className = 'status success';
                    return;
                }
                
                const decrypted = await cipher.decryptText(bytes, key);
                document.getElementById('resultOutput').textContent = 
                    `Расшифрованный текст: ${decrypted}`;
                
                document.getElementById('validationOutput').textContent = '✓ Дешифрование успешно';
                document.getElementById('validationOutput').className = 'status success';
            } catch (error) {
                document.getElementById('validationOutput').textContent = `✗ Ошибка: ${error.message}`;
                document.getElementById('validationOutput').className = 'status error';
            }
        }

        async function testReversibility() {
            const result = await cipher.testReversibility();
            
            if (result.success) {
                document.getElementById('resultOutput').textContent = 
                    `Тест пройден успешно!\nОригинал: "${result.original}"\nРезультат: "${result.decrypted}"`;
                document.getElementById('validationOutput').textContent = '✓ Тест обратимости пройден';
                document.getElementById('validationOutput').className = 'status success';
            } else {
                document.getElementById('resultOutput').textContent = 
                    `Ошибка в тесте: ${result.error || 'Неизвестная ошибка'}`;
                document.getElementById('validationOutput').textContent = '✗ Тест обратимости не пройден';
                document.getElementById('validationOutput').className = 'status error';
            }
        }
    </script>
</body>
</html>
